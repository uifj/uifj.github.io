<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://uifj.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://uifj.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-11T10:17:28+00:00</updated><id>https://uifj.github.io/feed.xml</id><title type="html">帆鸣_uifj</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">最佳实践案例</title><link href="https://uifj.github.io/blog/2025/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/" rel="alternate" type="text/html" title="最佳实践案例"/><published>2025-04-11T00:00:00+00:00</published><updated>2025-04-11T00:00:00+00:00</updated><id>https://uifj.github.io/blog/2025/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B</id><content type="html" xml:base="https://uifj.github.io/blog/2025/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/"><![CDATA[<h2 id="问题汇总1">问题汇总（1）</h2> <p>在Godot企业级游戏开发中，音频管理和存档系统的实现通常需要权衡代码的可维护性、可测试性和开发效率。以下是具体分析及实践方案：</p> <hr/> <h3 id="1-音频管理系统"><strong>1. 音频管理系统</strong></h3> <h4 id="常用方案"><strong>常用方案</strong></h4> <p>• <strong>单例模式（AutoLoad）</strong> • <strong>实现方式</strong>：通过Godot的<code class="language-plaintext highlighter-rouge">AutoLoad</code>功能将<code class="language-plaintext highlighter-rouge">AudioManager</code>设为全局单例。 • <strong>优点</strong>： ◦ 快速访问音频接口，如<code class="language-plaintext highlighter-rouge">AudioManager.play_sound("shoot")</code>。 ◦ 集中管理音频资源、音量设置和播放队列。 • <strong>缺点</strong>： ◦ 全局状态可能引发隐式耦合，单元测试需依赖单例实例。 • <strong>适用场景</strong>：中小型项目，或需要高频全局访问的音频系统。</p> <p>• <strong>依赖注入（Dependency Injection）</strong> • <strong>实现方式</strong>： ◦ 在场景初始化时，将<code class="language-plaintext highlighter-rouge">AudioManager</code>实例作为参数传递给依赖它的节点。 ◦ 使用Godot的<code class="language-plaintext highlighter-rouge">@export</code>注解将管理器暴露到编辑器，手动拖拽赋值。 • <strong>优点</strong>： ◦ 明确依赖关系，便于替换实现（如静音模式或测试桩）。 ◦ 提高模块化，适合多人协作的大型项目。 • <strong>缺点</strong>： ◦ 增加初始化复杂度，需手动传递依赖。 • <strong>适用场景</strong>：需要严格解耦的企业级项目，或支持多平台差异化音频逻辑。</p> <hr/> <h3 id="2-存档管理系统"><strong>2. 存档管理系统</strong></h3> <h4 id="常用方案-1"><strong>常用方案</strong></h4> <p>• <strong>单例模式（AutoLoad）</strong> • <strong>实现方式</strong>：将<code class="language-plaintext highlighter-rouge">SaveManager</code>设为AutoLoad单例，提供<code class="language-plaintext highlighter-rouge">save_game()</code>和<code class="language-plaintext highlighter-rouge">load_game()</code>接口。 • <strong>优点</strong>： ◦ 统一处理文件I/O、加密、版本迁移等底层逻辑。 ◦ 方便全局监听存档事件（如自动保存）。 • <strong>缺点</strong>： ◦ 存档逻辑与业务代码可能过度耦合。 • <strong>优化</strong>：通过<strong>观察者模式</strong>发送信号（如<code class="language-plaintext highlighter-rouge">save_completed</code>）解耦业务响应。</p> <p>• <strong>服务定位器模式</strong> • <strong>实现方式</strong>：通过一个全局的<code class="language-plaintext highlighter-rouge">ServiceLocator</code>提供<code class="language-plaintext highlighter-rouge">get_save_service()</code>，允许动态替换服务实现。 • <strong>优点</strong>： ◦ 兼顾全局访问的便利性和接口抽象（如本地存档 vs 云存档）。 ◦ 避免直接依赖具体类。 • <strong>适用场景</strong>：需要支持多种存档后端（如Steam云存档、本地文件）。</p> <hr/> <h3 id="3-企业级开发中的关键实践"><strong>3. 企业级开发中的关键实践</strong></h3> <ol> <li> <p><strong>混合模式策略</strong> • <strong>核心系统用单例</strong>：如全局配置、存档、音频。 • <strong>业务模块用依赖注入</strong>：如将<code class="language-plaintext highlighter-rouge">AudioManager</code>注入到<code class="language-plaintext highlighter-rouge">Player</code>节点，而非直接调用全局变量。</p> </li> <li><strong>代码隔离与接口抽象</strong> • 为存档管理定义<code class="language-plaintext highlighter-rouge">ISaveService</code>接口，允许替换实现（如测试用的内存存档）。 • 示例： <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 接口定义（通过GDscript的虚方法模拟）</span>
  <span class="k">class_name</span> <span class="n">ISaveService</span>
  <span class="k">func</span> <span class="nf">save_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">:</span> <span class="k">pass</span>

  <span class="c1"># 具体实现</span>
  <span class="k">class</span> <span class="nc">LocalSaveService</span> <span class="k">extends</span> <span class="n">ISaveService</span><span class="p">:</span>
      <span class="k">func</span> <span class="nf">save_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">:</span>
          <span class="c1"># 实际保存逻辑</span>
          <span class="k">return</span> <span class="bp">true</span>
</code></pre></div> </div> </li> <li><strong>信号解耦</strong> • 用Godot信号通知存档/音频事件，而非直接调用方法： <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 存档完成后发送信号</span>
  <span class="n">SignalBus</span><span class="o">.</span><span class="n">emit_signal</span><span class="p">(</span><span class="s2">"save_finished"</span><span class="p">)</span>
  <span class="c1"># 其他节点监听信号</span>
  <span class="n">SignalBus</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">"save_finished"</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">"_on_save_finished"</span><span class="p">)</span>
</code></pre></div> </div> </li> <li><strong>测试友好设计</strong> • 通过依赖注入替换单例： <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 测试中用MockAudioManager替换真实单例</span>
  <span class="k">func</span> <span class="nf">test_shoot_sound</span><span class="p">():</span>
      <span class="k">var</span> <span class="n">mock_audio</span> <span class="o">=</span> <span class="n">MockAudioManager</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
      <span class="n">player</span><span class="o">.</span><span class="n">audio_manager</span> <span class="o">=</span> <span class="n">mock_audio</span>
      <span class="n">player</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
      <span class="nb">assert</span><span class="p">(</span><span class="n">mock_audio</span><span class="o">.</span><span class="n">last_played</span> <span class="o">==</span> <span class="s2">"shoot"</span><span class="p">)</span>
</code></pre></div> </div> </li> </ol> <hr/> <h3 id="总结"><strong>总结</strong></h3> <p>• <strong>推荐方案</strong>： • <strong>单例模式（AutoLoad）</strong>：适用于高频访问的基础服务（如音频、存档），配合信号解耦。 • <strong>依赖注入</strong>：用于需要高可测试性和模块化的复杂业务逻辑。 • <strong>避免全局变量</strong>：直接使用全局变量会破坏封装性，应通过AutoLoad或服务定位器抽象。 • <strong>Godot特性结合</strong>：善用<code class="language-plaintext highlighter-rouge">@export</code>暴露依赖、<code class="language-plaintext highlighter-rouge">SignalBus</code>全局信号总线，平衡开发效率与架构质量。</p> <h2 id="问题汇总2">问题汇总（2）</h2> <p>在Godot游戏开发中，除了依赖注入外，还有许多最佳实践可以提升代码质量、可维护性和团队协作效率。以下是详细说明及具体示例：</p> <hr/> <h3 id="1-场景分层与模块化">1. <strong>场景分层与模块化</strong></h3> <p><strong>核心思想</strong>：将游戏拆分为独立、可复用的场景，通过组合而非继承构建复杂系统。<br/> <strong>实现方法</strong>： • <strong>子场景封装</strong>：将功能单元（如玩家的攻击组件、UI控件）封装成独立场景，通过实例化复用。 • <strong>场景树分层</strong>：例如将游戏分为 <code class="language-plaintext highlighter-rouge">Main</code>（根）、<code class="language-plaintext highlighter-rouge">UI</code>、<code class="language-plaintext highlighter-rouge">World</code>（游戏世界）、<code class="language-plaintext highlighter-rouge">Player</code> 等层级，避免节点混乱。</p> <p><strong>示例</strong>：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 场景结构
Main (Node2D)
├── UI (CanvasLayer)
│   ├── HealthBar.tscn
│   └── PauseMenu.tscn
└── World (Node2D)
    ├── Player.tscn
    └── Enemies (Node2D)
        ├── EnemyA.tscn
        └── EnemyB.tscn
</code></pre></div></div> <p><strong>优点</strong>： • 减少场景复杂度，便于多人协作。 • 通过 <code class="language-plaintext highlighter-rouge">Ctrl + S</code> 保存场景即可完成模块更新。</p> <hr/> <h3 id="2-信号驱动的通信">2. <strong>信号驱动的通信</strong></h3> <p><strong>核心思想</strong>：用Godot内置的 <strong>信号系统（Signals）</strong> 替代直接方法调用，实现松耦合。<br/> <strong>实现方法</strong>： • 为节点定义自定义信号（如 <code class="language-plaintext highlighter-rouge">player_damaged</code>），其他节点通过 <code class="language-plaintext highlighter-rouge">connect</code> 监听。 • 使用 <strong>全局信号总线（SignalBus）</strong> 统一管理跨场景通信。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 全局Signal.gd（AutoLoad单例）</span>
<span class="k">signal</span> <span class="n">player_took_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
<span class="k">signal</span> <span class="n">game_paused</span>

<span class="c1"># Player.gd</span>
<span class="k">func</span> <span class="nf">take_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="n">emit_signal</span><span class="p">(</span><span class="s2">"player_took_damage"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

<span class="c1"># UI/HealthBar.gd</span>
<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="n">SignalBus</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">"player_took_damage"</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">"_update_health"</span><span class="p">)</span>

<span class="k">func</span> <span class="nf">_update_health</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="c1"># 更新血条逻辑</span>
</code></pre></div></div> <p><strong>优点</strong>： • 彻底解耦发送者和接收者，无需知道对方存在。 • 适用于跨场景事件（如成就系统、全局UI更新）。</p> <hr/> <h3 id="3-资源管理resource和resourceloader">3. <strong>资源管理（Resource和ResourceLoader）</strong></h3> <p><strong>核心思想</strong>：利用Godot的 <strong>Resource</strong> 系统管理游戏数据，通过预加载和缓存优化性能。<br/> <strong>实现方法</strong>： • <strong>预加载常用资源</strong>：在启动时用 <code class="language-plaintext highlighter-rouge">preload</code> 或 <code class="language-plaintext highlighter-rouge">ResourceLoader.load</code> 加载关键资源。 • <strong>异步加载</strong>：使用 <code class="language-plaintext highlighter-rouge">ResourceLoader.load_interactive</code> 分帧加载大资源，避免卡顿。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 预定义资源类（如游戏设置）</span>
<span class="k">class_name</span> <span class="n">GameSettings</span> <span class="k">extends</span> <span class="n">Resource</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">master_volume</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">resolution</span><span class="p">:</span> <span class="kt">Vector2</span> <span class="o">=</span> <span class="kt">Vector2</span><span class="p">(</span><span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">)</span>

<span class="c1"># 加载资源</span>
<span class="k">var</span> <span class="n">settings</span><span class="p">:</span> <span class="n">GameSettings</span> <span class="o">=</span> <span class="n">ResourceLoader</span><span class="o">.</span><span class="nb">load</span><span class="p">(</span><span class="s2">"res://config/game_settings.tres"</span><span class="p">)</span>

<span class="c1"># 异步加载场景</span>
<span class="k">func</span> <span class="nf">load_level_async</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
    <span class="k">var</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">ResourceLoader</span><span class="o">.</span><span class="n">load_interactive</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">true</span><span class="p">:</span>
        <span class="k">var</span> <span class="n">err</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="n">ERR_FILE_EOF</span><span class="p">:</span>
            <span class="k">var</span> <span class="n">level</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_resource</span><span class="p">()</span>
            <span class="n">get_tree</span><span class="p">()</span><span class="o">.</span><span class="n">change_scene_to</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">OK</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="nb">yield</span><span class="p">(</span><span class="n">get_tree</span><span class="p">(),</span> <span class="s2">"idle_frame"</span><span class="p">)</span>  <span class="c1"># 分帧加载</span>
</code></pre></div></div> <p><strong>优点</strong>： • 资源与代码分离，便于非程序员修改（如美术调整材质）。 • 避免重复加载，提升性能。</p> <hr/> <h3 id="4-使用groups管理行为">4. <strong>使用Groups管理行为</strong></h3> <p><strong>核心思想</strong>：通过节点分组（Groups）批量操作或查询节点，替代遍历场景树。<br/> <strong>实现方法</strong>： • 将同类节点（如所有敌人）加入组（如 <code class="language-plaintext highlighter-rouge">"enemies"</code>），通过 <code class="language-plaintext highlighter-rouge">get_tree().get_nodes_in_group()</code> 获取。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 将所有敌人加入"enemies"组</span>
<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="n">add_to_group</span><span class="p">(</span><span class="s2">"enemies"</span><span class="p">)</span>

<span class="c1"># 暂停所有敌人</span>
<span class="k">func</span> <span class="nf">pause_all_enemies</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">enemy</span> <span class="ow">in</span> <span class="n">get_tree</span><span class="p">()</span><span class="o">.</span><span class="n">get_nodes_in_group</span><span class="p">(</span><span class="s2">"enemies"</span><span class="p">):</span>
        <span class="n">enemy</span><span class="o">.</span><span class="n">pause</span><span class="p">()</span>
</code></pre></div></div> <p><strong>优点</strong>： • 简化代码，避免硬编码节点路径。 • 动态管理分组（如 <code class="language-plaintext highlighter-rouge">remove_from_group()</code>）。</p> <hr/> <h3 id="5-state模式与状态机">5. <strong>State模式与状态机</strong></h3> <p><strong>核心思想</strong>：用状态机管理复杂对象（如玩家、敌人）的行为切换，避免条件分支膨胀。<br/> <strong>实现方法</strong>： • 每个状态封装为独立类，通过 <code class="language-plaintext highlighter-rouge">enter()</code>、<code class="language-plaintext highlighter-rouge">exit()</code>、<code class="language-plaintext highlighter-rouge">update()</code> 管理逻辑。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PlayerState.gd（基类）</span>
<span class="k">class_name</span> <span class="n">PlayerState</span>
<span class="k">func</span> <span class="nf">enter</span><span class="p">(</span><span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">):</span> <span class="k">pass</span>
<span class="k">func</span> <span class="nf">exit</span><span class="p">(</span><span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">):</span> <span class="k">pass</span>
<span class="k">func</span> <span class="nf">update</span><span class="p">(</span><span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="kt">float</span><span class="p">):</span> <span class="k">pass</span>

<span class="c1"># IdleState.gd</span>
<span class="k">extends</span> <span class="n">PlayerState</span>
<span class="k">func</span> <span class="nf">update</span><span class="p">(</span><span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="kt">float</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">Input</span><span class="o">.</span><span class="n">is_action_pressed</span><span class="p">(</span><span class="s2">"move_left"</span><span class="p">):</span>
        <span class="n">player</span><span class="o">.</span><span class="n">change_state</span><span class="p">(</span><span class="n">RunState</span><span class="o">.</span><span class="n">new</span><span class="p">())</span>

<span class="c1"># Player.gd</span>
<span class="k">var</span> <span class="n">current_state</span><span class="p">:</span> <span class="n">PlayerState</span>

<span class="k">func</span> <span class="nf">change_state</span><span class="p">(</span><span class="n">new_state</span><span class="p">:</span> <span class="n">PlayerState</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">current_state</span><span class="p">:</span>
        <span class="n">current_state</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">current_state</span> <span class="o">=</span> <span class="n">new_state</span>
    <span class="n">current_state</span><span class="o">.</span><span class="n">enter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="k">func</span> <span class="nf">_physics_process</span><span class="p">(</span><span class="n">delta</span><span class="p">):</span>
    <span class="n">current_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
</code></pre></div></div> <p><strong>优点</strong>： • 状态逻辑隔离，易于扩展新状态（如攀爬、游泳）。 • 避免大量 <code class="language-plaintext highlighter-rouge">if-else</code> 判断。</p> <hr/> <h3 id="6-避免过度继承多用组合">6. <strong>避免过度继承，多用组合</strong></h3> <p><strong>核心思想</strong>：利用Godot节点的组合特性，通过添加子节点实现功能扩展，而非深度继承。<br/> <strong>实现方法</strong>： • 将功能拆分为独立节点（如 <code class="language-plaintext highlighter-rouge">MovementComponent</code>、<code class="language-plaintext highlighter-rouge">AttackComponent</code>），挂载到父节点。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># MovementComponent.gd</span>
<span class="k">class_name</span> <span class="n">MovementComponent</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">speed</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">200.0</span>
<span class="k">var</span> <span class="n">velocity</span><span class="p">:</span> <span class="kt">Vector2</span> <span class="o">=</span> <span class="kt">Vector2</span><span class="o">.</span><span class="n">ZERO</span>

<span class="k">func</span> <span class="nf">move</span><span class="p">(</span><span class="n">direction</span><span class="p">:</span> <span class="kt">Vector2</span><span class="p">):</span>
    <span class="n">velocity</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">speed</span>

<span class="c1"># Player.gd</span>
<span class="err">@</span><span class="k">onready</span> <span class="k">var</span> <span class="n">movement</span><span class="p">:</span> <span class="n">MovementComponent</span> <span class="o">=</span> <span class="o">$</span><span class="n">MovementComponent</span>

<span class="k">func</span> <span class="nf">_physics_process</span><span class="p">(</span><span class="n">delta</span><span class="p">):</span>
    <span class="n">movement</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">Input</span><span class="o">.</span><span class="n">get_vector</span><span class="p">(</span><span class="s2">"move_left"</span><span class="p">,</span> <span class="s2">"move_right"</span><span class="p">,</span> <span class="s2">"move_up"</span><span class="p">,</span> <span class="s2">"move_down"</span><span class="p">))</span>
</code></pre></div></div> <p><strong>优点</strong>： • 功能模块化，可动态替换（如不同角色的移动方式）。 • 符合Godot“场景即预制体”的设计哲学。</p> <hr/> <h3 id="7-全局事件总线signalbus">7. <strong>全局事件总线（SignalBus）</strong></h3> <p><strong>核心思想</strong>：通过单例管理全局事件，避免直接引用其他节点。<br/> <strong>实现方法</strong>： • 创建 <code class="language-plaintext highlighter-rouge">SignalBus.gd</code> 作为AutoLoad单例，集中定义所有全局信号。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># SignalBus.gd（AutoLoad）</span>
<span class="k">signal</span> <span class="n">score_updated</span><span class="p">(</span><span class="n">new_score</span><span class="p">)</span>
<span class="k">signal</span> <span class="n">game_over</span>

<span class="c1"># 触发信号</span>
<span class="n">SignalBus</span><span class="o">.</span><span class="n">emit_signal</span><span class="p">(</span><span class="s2">"score_updated"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># 监听信号</span>
<span class="n">SignalBus</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">"score_updated"</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">"_on_score_updated"</span><span class="p">)</span>
</code></pre></div></div> <p><strong>优点</strong>： • 统一管理跨系统通信。 • 解耦事件发布者和订阅者。</p> <hr/> <h3 id="8-自动化测试与调试工具">8. <strong>自动化测试与调试工具</strong></h3> <p><strong>核心思想</strong>：通过单元测试和性能分析工具确保代码健壮性。<br/> <strong>实现方法</strong>： • 使用GDScript的 <code class="language-plaintext highlighter-rouge">assert()</code> 和 <code class="language-plaintext highlighter-rouge">test_</code> 前缀函数编写测试。 • 利用Godot编辑器的 <strong>调试器</strong> 和 <strong>性能分析器（Profiler）</strong>。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 测试玩家伤害逻辑</span>
<span class="k">func</span> <span class="nf">test_player_take_damage</span><span class="p">():</span>
    <span class="k">var</span> <span class="n">player</span> <span class="o">=</span> <span class="n">Player</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">player</span><span class="o">.</span><span class="n">health</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">player</span><span class="o">.</span><span class="n">take_damage</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="nb">assert</span><span class="p">(</span><span class="n">player</span><span class="o">.</span><span class="n">health</span> <span class="o">==</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div></div> <p><strong>工具推荐</strong>： • <strong>性能分析</strong>：查看CPU/GPU帧耗时、内存占用。 • <strong>远程调试</strong>：连接真机调试移动端游戏。</p> <hr/> <h3 id="9-版本控制与场景组织规范">9. <strong>版本控制与场景组织规范</strong></h3> <p><strong>核心思想</strong>：制定团队协作的目录结构和命名规范，避免冲突。<br/> <strong>推荐结构</strong>：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>res://
├── actors/         # 角色相关
├── ui/             # 界面
├── levels/         # 关卡
├── resources/      # 资源（音效、材质）
│   ├── audio/
│   └── textures/
└── scripts/        # 全局脚本
</code></pre></div></div> <p><strong>命名规范</strong>： • 场景文件：<code class="language-plaintext highlighter-rouge">名词_动词.tscn</code>（如 <code class="language-plaintext highlighter-rouge">enemy_flying.tscn</code>）。 • 脚本变量：<code class="language-plaintext highlighter-rouge">snake_case</code>，公开变量用 <code class="language-plaintext highlighter-rouge">@export</code>。</p> <hr/> <h3 id="10-自定义资源custom-resources">10. <strong>自定义资源（Custom Resources）</strong></h3> <p><strong>核心思想</strong>：将配置数据（如角色属性、关卡数据）存储为 <code class="language-plaintext highlighter-rouge">.tres</code> 文件，与代码分离。<br/> <strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># CharacterStats.gd</span>
<span class="k">class_name</span> <span class="n">CharacterStats</span> <span class="k">extends</span> <span class="n">Resource</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">max_health</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">100</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">speed</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">150.0</span>

<span class="c1"># 在编辑器中创建CharacterStats资源并赋值</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">stats</span><span class="p">:</span> <span class="n">CharacterStats</span>
</code></pre></div></div> <p><strong>优点</strong>： • 非程序员可直接在编辑器中调整数值。 • 支持继承资源（<code class="language-plaintext highlighter-rouge">class_name InheritedStats extends CharacterStats</code>）。</p> <hr/> <h3 id="总结-1"><strong>总结</strong></h3> <p>Godot的最佳实践核心是 <strong>“充分利用引擎特性，保持代码简洁、模块化”</strong>：</p> <ol> <li><strong>优先场景和节点组合</strong>，而非复杂继承。</li> <li><strong>全局通信用信号</strong>，避免直接调用。</li> <li><strong>资源与代码分离</strong>，提升可维护性。</li> <li><strong>自动化测试</strong>确保关键逻辑稳定。</li> </ol> <p>这些实践结合Godot的节点树、信号系统和资源管理，能显著提升企业级项目的开发效率和代码质量。</p> <h2 id="问题汇总3">问题汇总（3）</h2> <p>在Godot企业级游戏开发中，遵循特定的设计原则和模式可以显著提升代码的可维护性、扩展性和团队协作效率。以下是详细总结及具体应用场景：</p> <hr/> <h3 id="一核心设计原则"><strong>一、核心设计原则</strong></h3> <h4 id="1-solid原则">1. <strong>SOLID原则</strong></h4> <p>• <strong>Single Responsibility (单一职责)</strong><br/> ◦ 每个类/节点只负责一个功能（如 <code class="language-plaintext highlighter-rouge">MovementComponent</code> 仅处理移动逻辑）。 • <strong>Open/Closed (开闭原则)</strong><br/> ◦ 通过继承 <code class="language-plaintext highlighter-rouge">Resource</code> 扩展物品类型，而非修改原有代码。 • <strong>Liskov Substitution (里氏替换)</strong><br/> ◦ 子类技能必须兼容父类接口（如所有技能实现 <code class="language-plaintext highlighter-rouge">activate()</code> 方法）。 • <strong>Interface Segregation (接口隔离)</strong><br/> ◦ 为装备和消耗品定义不同的接口（<code class="language-plaintext highlighter-rouge">IEquippable</code>、<code class="language-plaintext highlighter-rouge">IConsumable</code>）。 • <strong>Dependency Inversion (依赖倒置)</strong><br/> ◦ 通过依赖注入传递存档服务（如 <code class="language-plaintext highlighter-rouge">ISaveService</code>）。</p> <h4 id="2-组合优于继承-composition-over-inheritance">2. <strong>组合优于继承 (Composition over Inheritance)</strong></h4> <p>• 使用节点组合构建角色：将 <code class="language-plaintext highlighter-rouge">AttackComponent</code>、<code class="language-plaintext highlighter-rouge">InventoryComponent</code> 挂载到 <code class="language-plaintext highlighter-rouge">Player</code> 节点，而非创建多层继承。</p> <h4 id="3-dont-repeat-yourself-dry">3. <strong>Don’t Repeat Yourself (DRY)</strong></h4> <p>• 将通用逻辑（如对象池管理）封装在 <code class="language-plaintext highlighter-rouge">Utils/ObjectPool.gd</code> 中。</p> <h4 id="4-kiss-keep-it-simple">4. <strong>KISS (Keep It Simple)</strong></h4> <p>• 避免过度设计：小型模块直接使用Godot信号，而非强制引入复杂框架。</p> <hr/> <h3 id="二常用设计模式及企业级应用"><strong>二、常用设计模式及企业级应用</strong></h3> <h4 id="1-单例模式-singleton">1. <strong>单例模式 (Singleton)</strong></h4> <p>• <strong>实现方式</strong>：通过 <code class="language-plaintext highlighter-rouge">AutoLoad</code> 创建全局服务。 • <strong>应用场景</strong>： ◦ <strong>存档管理</strong>：<code class="language-plaintext highlighter-rouge">SaveManager</code> 统一处理加密、云同步。 ◦ <strong>音频管理</strong>：<code class="language-plaintext highlighter-rouge">AudioManager</code> 控制音效优先级和混音。 ◦ <strong>全局事件总线</strong>：<code class="language-plaintext highlighter-rouge">SignalBus</code> 管理跨系统通信。</p> <h4 id="2-观察者模式-observer">2. <strong>观察者模式 (Observer)</strong></h4> <p>• <strong>实现方式</strong>：Godot内置的 <code class="language-plaintext highlighter-rouge">信号（Signals）</code>。 • <strong>应用场景</strong>： ◦ <strong>背包系统</strong>：物品数量变化时发送 <code class="language-plaintext highlighter-rouge">item_updated</code> 信号更新UI。 ◦ <strong>成就系统</strong>：监听 <code class="language-plaintext highlighter-rouge">enemy_killed</code> 事件触发成就解锁。 ◦ <strong>技能系统</strong>：技能冷却结束时通知UI刷新按钮状态。</p> <h4 id="3-工厂模式-factory">3. <strong>工厂模式 (Factory)</strong></h4> <p>• <strong>实现方式</strong>：通过 <code class="language-plaintext highlighter-rouge">ResourceLoader</code> 动态创建对象。 • <strong>应用场景</strong>： ◦ <strong>物品生成</strong>：<code class="language-plaintext highlighter-rouge">ItemFactory.create_item("sword")</code> 根据ID生成装备。 ◦ <strong>敌人生成</strong>：<code class="language-plaintext highlighter-rouge">EnemyFactory.spawn("boss")</code> 加载不同敌人场景。</p> <h4 id="4-状态模式-state">4. <strong>状态模式 (State)</strong></h4> <p>• <strong>实现方式</strong>：每个状态封装为独立类。 • <strong>应用场景</strong>： ◦ <strong>玩家控制</strong>：<code class="language-plaintext highlighter-rouge">IdleState</code>、<code class="language-plaintext highlighter-rouge">RunState</code>、<code class="language-plaintext highlighter-rouge">AttackState</code> 管理行为切换。 ◦ <strong>游戏流程</strong>：<code class="language-plaintext highlighter-rouge">MainMenuState</code>、<code class="language-plaintext highlighter-rouge">PlayingState</code>、<code class="language-plaintext highlighter-rouge">PausedState</code> 控制游戏阶段。</p> <h4 id="5-策略模式-strategy">5. <strong>策略模式 (Strategy)</strong></h4> <p>• <strong>实现方式</strong>：通过接口抽象算法。 • <strong>应用场景</strong>： ◦ <strong>存档格式</strong>：定义 <code class="language-plaintext highlighter-rouge">ISaveStrategy</code>，实现 <code class="language-plaintext highlighter-rouge">JsonSaveStrategy</code> 和 <code class="language-plaintext highlighter-rouge">BinarySaveStrategy</code>。 ◦ <strong>伤害计算</strong>：<code class="language-plaintext highlighter-rouge">DamageCalculator</code> 支持多种算法（如物理、魔法、暴击）。</p> <h4 id="6-命令模式-command">6. <strong>命令模式 (Command)</strong></h4> <p>• <strong>实现方式</strong>：封装操作为可撤销的对象。 • <strong>应用场景</strong>： ◦ <strong>技能释放</strong>：<code class="language-plaintext highlighter-rouge">CastFireballCommand</code> 记录施法目标和时间，支持撤销。 ◦ <strong>UI操作</strong>：实现编辑器的撤销/重做功能。</p> <h4 id="7-对象池模式-object-pool">7. <strong>对象池模式 (Object Pool)</strong></h4> <p>• <strong>实现方式</strong>：预实例化对象并重复利用。 • <strong>应用场景</strong>： ◦ <strong>子弹管理</strong>：避免频繁实例化/销毁子弹对象。 ◦ <strong>粒子效果</strong>：复用爆炸、烟雾等特效节点。</p> <hr/> <h3 id="三企业级模块设计与实现"><strong>三、企业级模块设计与实现</strong></h3> <h4 id="1-背包系统">1. <strong>背包系统</strong></h4> <p>• <strong>设计要点</strong>： ◦ <strong>数据分离</strong>：用 <code class="language-plaintext highlighter-rouge">InventoryItem</code> 资源定义物品属性。 ◦ <strong>拖拽交互</strong>：通过 <code class="language-plaintext highlighter-rouge">Control</code> 节点的 <code class="language-plaintext highlighter-rouge">_get_drag_data</code> 和 <code class="language-plaintext highlighter-rouge">_drop_data</code> 实现。 ◦ <strong>动态渲染</strong>：使用 <code class="language-plaintext highlighter-rouge">GridContainer</code> 和对象池管理槽位UI。 • <strong>代码示例</strong>： <code class="language-plaintext highlighter-rouge">gdscript # 物品拖拽 func _get_drag_data(position: Vector2): var item = slots[slot_index].item var preview = TextureRect.new() preview.texture = item.icon set_drag_preview(preview) return {"source_slot": slot_index, "item": item} </code></p> <h4 id="2-技能系统">2. <strong>技能系统</strong></h4> <p>• <strong>设计要点</strong>： ◦ <strong>技能数据驱动</strong>：用 <code class="language-plaintext highlighter-rouge">SkillData</code> 资源定义冷却时间、伤害公式。 ◦ <strong>组合技能</strong>：通过 <code class="language-plaintext highlighter-rouge">CompositeSkill</code> 组合多个基础技能（如冰火融合技）。 ◦ <strong>状态同步</strong>：用信号通知技能就绪状态（<code class="language-plaintext highlighter-rouge">skill_ready</code>、<code class="language-plaintext highlighter-rouge">skill_cooldown</code>）。 • <strong>代码示例</strong>： ```gdscript # 技能基类 class_name BaseSkill extends Resource signal cooldown_updated(remaining: float)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> func activate(caster: Node) -&gt; bool:
     # 由子类实现具体逻辑
     pass
 ```
</code></pre></div></div> <h4 id="3-存档管理">3. <strong>存档管理</strong></h4> <p>• <strong>设计要点</strong>： ◦ <strong>版本兼容</strong>：存档数据包含版本号，支持旧版迁移。 ◦ <strong>异步保存</strong>：使用 <code class="language-plaintext highlighter-rouge">Thread</code> 或 <code class="language-plaintext highlighter-rouge">Mutex</code> 避免主线程卡顿。 ◦ <strong>加密存储</strong>：通过 <code class="language-plaintext highlighter-rouge">Crypto</code> 类对敏感数据加密。 • <strong>代码示例</strong>： ```gdscript # 异步保存 func save_async(path: String): var thread = Thread.new() thread.start(_save_data.bind(path))</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> func _save_data(path: String):
     var json = JSON.stringify(data)
     ResourceSaver.save(json, path)
 ```
</code></pre></div></div> <h4 id="4-ai系统">4. <strong>AI系统</strong></h4> <p>• <strong>设计要点</strong>： ◦ <strong>行为树</strong>：用 <code class="language-plaintext highlighter-rouge">BehaviorTree</code> 节点实现复杂AI逻辑。 ◦ <strong>感知系统</strong>：通过 <code class="language-plaintext highlighter-rouge">Area2D</code> 检测玩家位置。 ◦ <strong>配置化</strong>：用 <code class="language-plaintext highlighter-rouge">AIConfig</code> 资源调整AI参数（如巡逻半径、反应速度）。</p> <h4 id="5-网络同步多人游戏">5. <strong>网络同步（多人游戏）</strong></h4> <p>• <strong>设计要点</strong>： ◦ <strong>权威服务器</strong>：关键逻辑（如伤害计算）在服务器执行。 ◦ <strong>状态同步</strong>：通过 <code class="language-plaintext highlighter-rouge">multiplayer</code> API同步玩家位置、状态。 ◦ <strong>预测与插值</strong>：客户端实现移动预测，平滑显示其他玩家动作。</p> <hr/> <h3 id="四godot特性深度结合"><strong>四、Godot特性深度结合</strong></h3> <ol> <li> <p><strong>节点树与场景化开发</strong><br/> • 将功能拆分为子场景（如 <code class="language-plaintext highlighter-rouge">UI/PopupDialog.tscn</code>），通过 <code class="language-plaintext highlighter-rouge">instance()</code> 动态加载。</p> </li> <li> <p><strong>资源系统（Resource）</strong><br/> • 用 <code class="language-plaintext highlighter-rouge">.tres</code> 文件存储配置数据（如角色属性、关卡配置）。</p> </li> <li><strong>信号系统</strong><br/> • 替代回调函数，实现解耦： <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 发送信号</span>
  <span class="n">SignalBus</span><span class="o">.</span><span class="n">emit_signal</span><span class="p">(</span><span class="s2">"player_health_changed"</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>
  <span class="c1"># 监听信号</span>
  <span class="n">SignalBus</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">"player_health_changed"</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">update_health_bar</span><span class="p">)</span>
</code></pre></div> </div> </li> <li><strong>编辑器扩展</strong><br/> • 通过 <code class="language-plaintext highlighter-rouge">@tool</code> 脚本创建自定义编辑器工具，提升团队效率。</li> </ol> <hr/> <h3 id="五企业级开发注意事项"><strong>五、企业级开发注意事项</strong></h3> <ol> <li> <p><strong>代码规范</strong><br/> • 强制使用静态类型（<code class="language-plaintext highlighter-rouge">var health: int = 100</code>）和命名约定（如 <code class="language-plaintext highlighter-rouge">snake_case</code>）。</p> </li> <li> <p><strong>性能优化</strong><br/> • 使用 <code class="language-plaintext highlighter-rouge">Profiler</code> 分析CPU/GPU耗时，避免每帧执行高开销操作。</p> </li> <li> <p><strong>跨平台适配</strong><br/> • 通过 <code class="language-plaintext highlighter-rouge">OS.get_name()</code> 处理平台差异（如移动端虚拟摇杆、PC端键鼠控制）。</p> </li> <li> <p><strong>自动化测试</strong><br/> • 编写单元测试验证核心逻辑（如伤害计算、物品堆叠）。</p> </li> </ol> <hr/> <h3 id="总结-2"><strong>总结</strong></h3> <p>在Godot企业级开发中，关键在于 <strong>“充分利用引擎特性，结合经典设计模式”</strong>： • <strong>原则</strong>：优先使用组合、SOLID、DRY。 • <strong>模式</strong>：单例、观察者、工厂、状态模式为核心。 • <strong>实践</strong>：模块化拆分、数据驱动设计、资源与代码分离。</p> <p>通过以上方法，可以在复杂项目（如开放世界RPG、MMO）中实现高效协作和长期维护。</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="Godot"/><category term="GDScript"/><category term="note"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">依赖注入的最佳实践</title><link href="https://uifj.github.io/blog/2025/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="alternate" type="text/html" title="依赖注入的最佳实践"/><published>2025-04-09T00:00:00+00:00</published><updated>2025-04-09T00:00:00+00:00</updated><id>https://uifj.github.io/blog/2025/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5</id><content type="html" xml:base="https://uifj.github.io/blog/2025/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><![CDATA[<p>遵循最佳实践，为了实现解耦。</p> <p>遵循Godot最佳实践：</p> <ul> <li>使用@export注解替代直接变量声明，提高配置的灵活性</li> <li>优化信号连接方式，使用新的连接语法</li> <li>改进输入处理系统，将输入逻辑分离到专门的方法中</li> <li>使用Godot的内置类型和工具提升性能</li> <li>添加更多的类型注解，提高代码的可读性和可维护性</li> <li>优化错误处理和日志记录，使用格式化字符串</li> <li>重构进化系统，将相关功能模块化</li> <li>改进代码组织结构，提高代码的可维护性</li> </ul> <ol> <li>输入系统优化 <ul> <li>添加了输入冷却机制，防止快速连续按键导致的方向突变</li> <li>改进了方向变更的验证逻辑</li> <li>增加了输入状态管理</li> </ul> </li> <li>移动系统改进 <ul> <li>实现了预测性碰撞检测</li> <li>优化了移动逻辑，提高了代码可读性和维护性</li> <li>将位置验证逻辑封装到独立函数中</li> </ul> </li> <li>装饰系统增强 <ul> <li>为所有装饰物添加了错误处理机制</li> <li>增加了配置验证</li> <li>改进了装饰物的创建和清理流程</li> <li>添加了详细的日志记录</li> </ul> </li> <li>使用Godot的信号系统替代直接函数调用，实现更好的解耦；</li> <li>优化节点结构，合理使用节点组和自动加载单例；</li> <li>改进资源加载和场景管理机制；</li> <li>使用Godot的内置类型和工具进行性能优化；</li> <li>规范化节点命名和场景组织。我会首先对Snake.gd进行重构，然后逐步完善其他相关文件。</li> <li>使用@export注解替代直接变量声明，优化信号连接方式，使用内置类型提升性能，并添加类型注解。</li> <li>重点改进碰撞检测和移动逻辑，使用Godot的内置类型和工具提升性能，同时优化错误处理。</li> </ol> <ul> <li>核心架构优化：使用节点组和自动加载单例，实现MVC模式分离</li> <li>信号系统重构：采用新版信号语法，优化组件间通信</li> <li>输入系统改进：实现InputHandler类，处理输入验证和状态管理</li> <li>碰撞系统优化：使用内置物理系统，实现高效碰撞检测</li> <li>移动系统完善：实现预测性碰撞检测，优化移动逻辑</li> <li>资源管理优化：改进场景加载机制，实现资源预加载</li> <li>类型系统规范：添加类型注解，使用@export优化配置</li> <li>错误处理增强：实现统一的错误处理和日志系统</li> <li>装饰系统改进：优化特效和视觉反馈系统</li> <li>性能优化：使用对象池，优化渲染和内存使用</li> <li>代码规范化：统一命名规范，优化代码组织结构</li> <li>调试功能：添加调试模式和性能监控工具 扩展最佳时间的说明内容排序，将上面的内容，要更详细，更完善，因为我打算按照企业级游戏开发标准，完成一个2d冒险类rpg游戏，有战斗系统、boss机制、高级状态机行为树、背包系统、任务系统、存档管理、音频管理等等功能。</li> </ul> <p>在 Godot 中使用依赖注入（Dependency Injection）与常规节点引用方式有本质区别，尤其是在复杂项目架构中。以下通过具体场景和 GDScript 示例说明二者的区别及适用场景：</p> <hr/> <h1 id="依赖注入与最佳实践">依赖注入与最佳实践</h1> <h3 id="一常规节点引用方式"><strong>一、常规节点引用方式</strong></h3> <h4 id="典型场景"><strong>典型场景</strong>：</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Player.gd</span>
<span class="k">extends</span> <span class="n">CharacterBody2D</span>

<span class="k">func</span> <span class="nf">take_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="k">var</span> <span class="n">hud</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="s2">"/root/MainScene/HUD"</span><span class="p">)</span> <span class="c1"># 直接通过路径获取</span>
    <span class="n">hud</span><span class="o">.</span><span class="n">update_health_bar</span><span class="p">(</span><span class="n">health</span><span class="p">)</span>
    
    <span class="k">var</span> <span class="n">sound_mgr</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="s2">"/root/SoundManager"</span><span class="p">)</span> <span class="c1"># 依赖全局单例</span>
    <span class="n">sound_mgr</span><span class="o">.</span><span class="n">play_sound</span><span class="p">(</span><span class="s2">"hurt"</span><span class="p">)</span>
</code></pre></div></div> <p><strong>问题</strong>： • <strong>紧耦合</strong>：直接依赖具体节点路径和单例 • <strong>难以测试</strong>：无法替换 <code class="language-plaintext highlighter-rouge">HUD</code> 或 <code class="language-plaintext highlighter-rouge">SoundManager</code> 的模拟实现 • <strong>维护困难</strong>：节点路径变更需修改多处代码</p> <hr/> <h3 id="二依赖注入实现"><strong>二、依赖注入实现</strong></h3> <h4 id="1-构造函数注入"><strong>1. 构造函数注入</strong>：</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Player.gd</span>
<span class="k">extends</span> <span class="n">CharacterBody2D</span>

<span class="k">var</span> <span class="n">hud</span><span class="p">:</span> <span class="n">HUD</span>
<span class="k">var</span> <span class="n">sound_mgr</span><span class="p">:</span> <span class="n">SoundManager</span>

<span class="k">func</span> <span class="nf">_init</span><span class="p">(</span><span class="n">hud_ref</span><span class="p">:</span> <span class="n">HUD</span><span class="p">,</span> <span class="n">sound_ref</span><span class="p">:</span> <span class="n">SoundManager</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hud</span> <span class="o">=</span> <span class="n">hud_ref</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sound_mgr</span> <span class="o">=</span> <span class="n">sound_ref</span>

<span class="k">func</span> <span class="nf">take_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="n">hud</span><span class="o">.</span><span class="n">update_health_bar</span><span class="p">(</span><span class="n">health</span><span class="p">)</span>
    <span class="n">sound_mgr</span><span class="o">.</span><span class="n">play_sound</span><span class="p">(</span><span class="s2">"hurt"</span><span class="p">)</span>

<span class="c1"># 场景初始化时</span>
<span class="k">var</span> <span class="n">player</span> <span class="o">=</span> <span class="n">PlayerScene</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">hud_node</span><span class="p">,</span> <span class="n">sound_mgr_node</span><span class="p">)</span>
</code></pre></div></div> <p><strong>优势</strong>：明确依赖关系，易替换实现</p> <h4 id="2-属性注入"><strong>2. 属性注入</strong>：</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># GameManager.gd</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">:</span>
    <span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">player</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">player</span><span class="o">.</span><span class="n">hud</span> <span class="o">=</span> <span class="o">$</span><span class="n">HUD</span>
        <span class="n">player</span><span class="o">.</span><span class="n">sound_mgr</span> <span class="o">=</span> <span class="o">$</span><span class="n">SoundManager</span>
</code></pre></div></div> <p><strong>优势</strong>：通过编辑器可视化配置依赖</p> <hr/> <h3 id="三依赖注入的典型应用场景"><strong>三、依赖注入的典型应用场景</strong></h3> <h4 id="1-跨场景服务共享"><strong>1. 跨场景服务共享</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 通过资源文件配置依赖</span>
<span class="c1"># config.tres</span>
<span class="k">extends</span> <span class="n">Resource</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">audio_service</span><span class="p">:</span> <span class="n">AudioService</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">save_service</span><span class="p">:</span> <span class="n">SaveService</span>

<span class="c1"># 注入到所有需要的地方</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">config</span><span class="p">:</span> <span class="n">ConfigResource</span>

<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="o">$</span><span class="n">Player</span><span class="o">.</span><span class="n">set_audio_service</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">audio_service</span><span class="p">)</span>
</code></pre></div></div> <h4 id="2-单元测试模拟"><strong>2. 单元测试模拟</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_player.gd</span>
<span class="k">func</span> <span class="nf">test_take_damage</span><span class="p">():</span>
    <span class="k">var</span> <span class="n">mock_hud</span> <span class="o">=</span> <span class="n">MockHUD</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="k">var</span> <span class="n">mock_sound</span> <span class="o">=</span> <span class="n">MockSoundManager</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="k">var</span> <span class="n">player</span> <span class="o">=</span> <span class="n">Player</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">mock_hud</span><span class="p">,</span> <span class="n">mock_sound</span><span class="p">)</span>
    
    <span class="n">player</span><span class="o">.</span><span class="n">take_damage</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">assert_true</span><span class="p">(</span><span class="n">mock_hud</span><span class="o">.</span><span class="n">health_updated_called</span><span class="p">)</span>
</code></pre></div></div> <h4 id="3-多平台差异化实现"><strong>3. 多平台差异化实现</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 移动端输入服务</span>
<span class="k">class</span> <span class="nc">MobileInputService</span> <span class="k">extends</span> <span class="n">InputService</span><span class="p">:</span>
    <span class="k">func</span> <span class="nf">get_move_direction</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Vector2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">touch_gesture_direction</span>

<span class="c1"># PC端输入服务  </span>
<span class="k">class</span> <span class="nc">PCInputService</span> <span class="k">extends</span> <span class="n">InputService</span><span class="p">:</span>
    <span class="k">func</span> <span class="nf">get_move_direction</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Vector2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Input</span><span class="o">.</span><span class="n">get_vector</span><span class="p">(</span><span class="s2">"left"</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">,</span> <span class="s2">"up"</span><span class="p">,</span> <span class="s2">"down"</span><span class="p">)</span>

<span class="c1"># 根据平台注入</span>
<span class="k">func</span> <span class="nf">_setup_input</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">OS</span><span class="o">.</span><span class="n">is_mobile</span><span class="p">():</span>
        <span class="n">player</span><span class="o">.</span><span class="n">input_service</span> <span class="o">=</span> <span class="n">MobileInputService</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">player</span><span class="o">.</span><span class="n">input_service</span> <span class="o">=</span> <span class="n">PCInputService</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
</code></pre></div></div> <hr/> <h3 id="四godot-依赖注入最佳实践"><strong>四、Godot 依赖注入最佳实践</strong></h3> <h4 id="1-接口抽象"><strong>1. 接口抽象</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># IAnalyticsService.gd</span>
<span class="k">extends</span> <span class="n">RefCounted</span>
<span class="k">class_name</span> <span class="n">IAnalyticsService</span>

<span class="k">func</span> <span class="nf">log_event</span><span class="p">(</span><span class="n">event_name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># 实现类</span>
<span class="k">class</span> <span class="nc">FirebaseAnalytics</span> <span class="k">extends</span> <span class="n">IAnalyticsService</span><span class="p">:</span>
    <span class="k">func</span> <span class="nf">log_event</span><span class="p">(</span><span class="n">event_name</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
        <span class="n">Firebase</span><span class="o">.</span><span class="n">Analytics</span><span class="o">.</span><span class="n">log_event</span><span class="p">(</span><span class="n">event_name</span><span class="p">)</span>
</code></pre></div></div> <h4 id="2-依赖容器"><strong>2. 依赖容器</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># DI Container</span>
<span class="k">var</span> <span class="n">services</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"analytics"</span><span class="p">:</span> <span class="n">FirebaseAnalytics</span><span class="o">.</span><span class="n">new</span><span class="p">(),</span>
    <span class="s2">"storage"</span><span class="p">:</span> <span class="n">CloudSaveService</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="nf">get_service</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">services</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="c1"># 使用端</span>
<span class="k">var</span> <span class="n">analytics</span> <span class="o">=</span> <span class="n">DIContainer</span><span class="o">.</span><span class="n">get_service</span><span class="p">(</span><span class="s2">"analytics"</span><span class="p">)</span>
<span class="n">analytics</span><span class="o">.</span><span class="n">log_event</span><span class="p">(</span><span class="s2">"game_start"</span><span class="p">)</span>
</code></pre></div></div> <h4 id="3-自动注入工具"><strong>3. 自动注入工具</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 通过特性标记自动注入</span>
<span class="k">class_name</span> <span class="n">Injectable</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">di_key</span><span class="p">:</span> <span class="kt">String</span>

<span class="k">func</span> <span class="nf">_enter_tree</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">DIContainer</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">di_key</span><span class="p">):</span>
        <span class="n">set</span><span class="p">(</span><span class="n">di_key</span><span class="p">,</span> <span class="n">DIContainer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">di_key</span><span class="p">))</span>

<span class="c1"># 使用</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">analytics</span><span class="p">:</span> <span class="n">IAnalyticsService</span><span class="p">:</span>
    <span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">analytics</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">add_to_group</span><span class="p">(</span><span class="s2">"injectable"</span><span class="p">,</span> <span class="bp">true</span><span class="p">)</span>
</code></pre></div></div> <hr/> <h3 id="五与传统方式的性能对比"><strong>五、与传统方式的性能对比</strong></h3> <p>| <strong>指标</strong> | <strong>常规方式</strong> | <strong>依赖注入</strong> | |—————-|————-|————-| | 代码耦合度 | 高 (⭐) | 低 (⭐⭐⭐⭐⭐) | | 可测试性 | 差 | 优 | | 启动时间 | 快 | 略慢(+5-10%)| | 内存占用 | 低 | 略高(+3-8%) | | 多平台适配成本 | 高 | 低 |</p> <hr/> <h3 id="六适用场景决策树"><strong>六、适用场景决策树</strong></h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>是否需要以下特性？
├─ 单元测试 → 需要DI
├─ 多平台构建 → 需要DI  
├─ 模块热替换 → 需要DI
├─ 长期维护 → 需要DI
└─ 快速原型 → 传统方式更合适
</code></pre></div></div> <p>依赖注入在 Godot 中特别适合中大型项目，通过解耦实现更好的架构控制。对于小型项目，直接使用 <code class="language-plaintext highlighter-rouge">get_node()</code> 和单例仍是合理选择。关键在于根据项目规模灵活选择架构方案。</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="Godot"/><category term="GDScript"/><category term="note"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">又开始幻想了“恼”！</title><link href="https://uifj.github.io/blog/2025/%E5%8F%88%E5%BC%80%E5%A7%8B%E5%B9%BB%E6%83%B3%E4%BA%86-%E6%81%BC/" rel="alternate" type="text/html" title="又开始幻想了“恼”！"/><published>2025-04-02T09:00:00+00:00</published><updated>2025-04-02T09:00:00+00:00</updated><id>https://uifj.github.io/blog/2025/%E5%8F%88%E5%BC%80%E5%A7%8B%E5%B9%BB%E6%83%B3%E4%BA%86%E2%80%9C%E6%81%BC%E2%80%9D</id><content type="html" xml:base="https://uifj.github.io/blog/2025/%E5%8F%88%E5%BC%80%E5%A7%8B%E5%B9%BB%E6%83%B3%E4%BA%86-%E6%81%BC/"><![CDATA[<h1 id="呼唤">呼唤</h1> <p>愚人节快乐！！</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="life"/><category term="charts"/><summary type="html"><![CDATA[幻想之作]]></summary></entry><entry><title type="html">手册学习之常用节点</title><link href="https://uifj.github.io/blog/2025/%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B8%B8%E7%94%A8%E8%8A%82%E7%82%B9/" rel="alternate" type="text/html" title="手册学习之常用节点"/><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://uifj.github.io/blog/2025/%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B8%B8%E7%94%A8%E8%8A%82%E7%82%B9</id><content type="html" xml:base="https://uifj.github.io/blog/2025/%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B8%B8%E7%94%A8%E8%8A%82%E7%82%B9/"><![CDATA[<p>This is an example post with some <a href="https://plotly.com/javascript/">plotly</a> code.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">plotly
</span><span class="sb">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "type": "scatter"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [16, 5, 11, 9],
      "type": "scatter"
    }
  ]
}</span>
<span class="p">```</span>
</code></pre></div></div> <p>Which generates:</p> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "type": "scatter"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [16, 5, 11, 9],
      "type": "scatter"
    }
  ]
}
</code></pre> <p>Also another example chart.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">plotly
</span><span class="sb">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}</span>
<span class="p">```</span>
</code></pre></div></div> <p>This is how it looks like:</p> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}
</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="Godot"/><category term="GDScript"/><category term="note"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">GDScript使用小技巧</title><link href="https://uifj.github.io/blog/2025/GDScript%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="alternate" type="text/html" title="GDScript使用小技巧"/><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://uifj.github.io/blog/2025/GDScript%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7</id><content type="html" xml:base="https://uifj.github.io/blog/2025/GDScript%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"><![CDATA[<h3 id="一操作符">一、操作符</h3> <h4 id="in">in</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 可以使用 In 运算符检查对象中是否存在给定的属性、方法或信号名称(信号是过去式)
var node = Node.new()
print("name" in node)         # Prints true
print("get_parent" in node)   # Prints true
print("tree_entered" in node) # Prints true
print("unknown" in node)      # Prints false
</code></pre></div></div>]]></content><author><name></name></author><category term="sample-posts"/><category term="Godot"/><category term="GDScript"/><category term="note"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">GDScript依赖注入实践</title><link href="https://uifj.github.io/blog/2025/GDScript%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" rel="alternate" type="text/html" title="GDScript依赖注入实践"/><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://uifj.github.io/blog/2025/GDScript%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5</id><content type="html" xml:base="https://uifj.github.io/blog/2025/GDScript%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"><![CDATA[<p>遵循最佳实践，为了实现解耦。</p> <p>遵循Godot最佳实践：</p> <ul> <li>使用@export注解替代直接变量声明，提高配置的灵活性</li> <li>优化信号连接方式，使用新的连接语法</li> <li>改进输入处理系统，将输入逻辑分离到专门的方法中</li> <li>使用Godot的内置类型和工具提升性能</li> <li>添加更多的类型注解，提高代码的可读性和可维护性</li> <li>优化错误处理和日志记录，使用格式化字符串</li> <li>重构进化系统，将相关功能模块化</li> <li>改进代码组织结构，提高代码的可维护性</li> </ul> <ol> <li>输入系统优化 <ul> <li>添加了输入冷却机制，防止快速连续按键导致的方向突变</li> <li>改进了方向变更的验证逻辑</li> <li>增加了输入状态管理</li> </ul> </li> <li>移动系统改进 <ul> <li>实现了预测性碰撞检测</li> <li>优化了移动逻辑，提高了代码可读性和维护性</li> <li>将位置验证逻辑封装到独立函数中</li> </ul> </li> <li>装饰系统增强 <ul> <li>为所有装饰物添加了错误处理机制</li> <li>增加了配置验证</li> <li>改进了装饰物的创建和清理流程</li> <li>添加了详细的日志记录</li> </ul> </li> <li>使用Godot的信号系统替代直接函数调用，实现更好的解耦；</li> <li>优化节点结构，合理使用节点组和自动加载单例；</li> <li>改进资源加载和场景管理机制；</li> <li>使用Godot的内置类型和工具进行性能优化；</li> <li>规范化节点命名和场景组织。我会首先对Snake.gd进行重构，然后逐步完善其他相关文件。</li> <li>使用@export注解替代直接变量声明，优化信号连接方式，使用内置类型提升性能，并添加类型注解。</li> <li>重点改进碰撞检测和移动逻辑，使用Godot的内置类型和工具提升性能，同时优化错误处理。</li> </ol> <ul> <li>核心架构优化：使用节点组和自动加载单例，实现MVC模式分离</li> <li>信号系统重构：采用新版信号语法，优化组件间通信</li> <li>输入系统改进：实现InputHandler类，处理输入验证和状态管理</li> <li>碰撞系统优化：使用内置物理系统，实现高效碰撞检测</li> <li>移动系统完善：实现预测性碰撞检测，优化移动逻辑</li> <li>资源管理优化：改进场景加载机制，实现资源预加载</li> <li>类型系统规范：添加类型注解，使用@export优化配置</li> <li>错误处理增强：实现统一的错误处理和日志系统</li> <li>装饰系统改进：优化特效和视觉反馈系统</li> <li>性能优化：使用对象池，优化渲染和内存使用</li> <li>代码规范化：统一命名规范，优化代码组织结构</li> <li>调试功能：添加调试模式和性能监控工具 扩展最佳时间的说明内容排序，将上面的内容，要更详细，更完善，因为我打算按照企业级游戏开发标准，完成一个2d冒险类rpg游戏，有战斗系统、boss机制、高级状态机行为树、背包系统、任务系统、存档管理、音频管理等等功能。</li> </ul> <p>在 Godot 中使用依赖注入（Dependency Injection）与常规节点引用方式有本质区别，尤其是在复杂项目架构中。以下通过具体场景和 GDScript 示例说明二者的区别及适用场景：</p> <hr/> <h1 id="依赖注入与最佳实践">依赖注入与最佳实践</h1> <h3 id="一常规节点引用方式"><strong>一、常规节点引用方式</strong></h3> <h4 id="典型场景"><strong>典型场景</strong>：</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Player.gd</span>
<span class="k">extends</span> <span class="n">CharacterBody2D</span>

<span class="k">func</span> <span class="nf">take_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="k">var</span> <span class="n">hud</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="s2">"/root/MainScene/HUD"</span><span class="p">)</span> <span class="c1"># 直接通过路径获取</span>
    <span class="n">hud</span><span class="o">.</span><span class="n">update_health_bar</span><span class="p">(</span><span class="n">health</span><span class="p">)</span>
    
    <span class="k">var</span> <span class="n">sound_mgr</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="s2">"/root/SoundManager"</span><span class="p">)</span> <span class="c1"># 依赖全局单例</span>
    <span class="n">sound_mgr</span><span class="o">.</span><span class="n">play_sound</span><span class="p">(</span><span class="s2">"hurt"</span><span class="p">)</span>
</code></pre></div></div> <p><strong>问题</strong>： • <strong>紧耦合</strong>：直接依赖具体节点路径和单例 • <strong>难以测试</strong>：无法替换 <code class="language-plaintext highlighter-rouge">HUD</code> 或 <code class="language-plaintext highlighter-rouge">SoundManager</code> 的模拟实现 • <strong>维护困难</strong>：节点路径变更需修改多处代码</p> <hr/> <h3 id="二依赖注入实现"><strong>二、依赖注入实现</strong></h3> <h4 id="1-构造函数注入"><strong>1. 构造函数注入</strong>：</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Player.gd</span>
<span class="k">extends</span> <span class="n">CharacterBody2D</span>

<span class="k">var</span> <span class="n">hud</span><span class="p">:</span> <span class="n">HUD</span>
<span class="k">var</span> <span class="n">sound_mgr</span><span class="p">:</span> <span class="n">SoundManager</span>

<span class="k">func</span> <span class="nf">_init</span><span class="p">(</span><span class="n">hud_ref</span><span class="p">:</span> <span class="n">HUD</span><span class="p">,</span> <span class="n">sound_ref</span><span class="p">:</span> <span class="n">SoundManager</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hud</span> <span class="o">=</span> <span class="n">hud_ref</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sound_mgr</span> <span class="o">=</span> <span class="n">sound_ref</span>

<span class="k">func</span> <span class="nf">take_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="n">hud</span><span class="o">.</span><span class="n">update_health_bar</span><span class="p">(</span><span class="n">health</span><span class="p">)</span>
    <span class="n">sound_mgr</span><span class="o">.</span><span class="n">play_sound</span><span class="p">(</span><span class="s2">"hurt"</span><span class="p">)</span>

<span class="c1"># 场景初始化时</span>
<span class="k">var</span> <span class="n">player</span> <span class="o">=</span> <span class="n">PlayerScene</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">hud_node</span><span class="p">,</span> <span class="n">sound_mgr_node</span><span class="p">)</span>
</code></pre></div></div> <p><strong>优势</strong>：明确依赖关系，易替换实现</p> <h4 id="2-属性注入"><strong>2. 属性注入</strong>：</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># GameManager.gd</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">:</span>
    <span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">player</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">player</span><span class="o">.</span><span class="n">hud</span> <span class="o">=</span> <span class="o">$</span><span class="n">HUD</span>
        <span class="n">player</span><span class="o">.</span><span class="n">sound_mgr</span> <span class="o">=</span> <span class="o">$</span><span class="n">SoundManager</span>
</code></pre></div></div> <p><strong>优势</strong>：通过编辑器可视化配置依赖</p> <hr/> <h3 id="三依赖注入的典型应用场景"><strong>三、依赖注入的典型应用场景</strong></h3> <h4 id="1-跨场景服务共享"><strong>1. 跨场景服务共享</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 通过资源文件配置依赖</span>
<span class="c1"># config.tres</span>
<span class="k">extends</span> <span class="n">Resource</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">audio_service</span><span class="p">:</span> <span class="n">AudioService</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">save_service</span><span class="p">:</span> <span class="n">SaveService</span>

<span class="c1"># 注入到所有需要的地方</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">config</span><span class="p">:</span> <span class="n">ConfigResource</span>

<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="o">$</span><span class="n">Player</span><span class="o">.</span><span class="n">set_audio_service</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">audio_service</span><span class="p">)</span>
</code></pre></div></div> <h4 id="2-单元测试模拟"><strong>2. 单元测试模拟</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_player.gd</span>
<span class="k">func</span> <span class="nf">test_take_damage</span><span class="p">():</span>
    <span class="k">var</span> <span class="n">mock_hud</span> <span class="o">=</span> <span class="n">MockHUD</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="k">var</span> <span class="n">mock_sound</span> <span class="o">=</span> <span class="n">MockSoundManager</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="k">var</span> <span class="n">player</span> <span class="o">=</span> <span class="n">Player</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">mock_hud</span><span class="p">,</span> <span class="n">mock_sound</span><span class="p">)</span>
    
    <span class="n">player</span><span class="o">.</span><span class="n">take_damage</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">assert_true</span><span class="p">(</span><span class="n">mock_hud</span><span class="o">.</span><span class="n">health_updated_called</span><span class="p">)</span>
</code></pre></div></div> <h4 id="3-多平台差异化实现"><strong>3. 多平台差异化实现</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 移动端输入服务</span>
<span class="k">class</span> <span class="nc">MobileInputService</span> <span class="k">extends</span> <span class="n">InputService</span><span class="p">:</span>
    <span class="k">func</span> <span class="nf">get_move_direction</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Vector2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">touch_gesture_direction</span>

<span class="c1"># PC端输入服务  </span>
<span class="k">class</span> <span class="nc">PCInputService</span> <span class="k">extends</span> <span class="n">InputService</span><span class="p">:</span>
    <span class="k">func</span> <span class="nf">get_move_direction</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Vector2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Input</span><span class="o">.</span><span class="n">get_vector</span><span class="p">(</span><span class="s2">"left"</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">,</span> <span class="s2">"up"</span><span class="p">,</span> <span class="s2">"down"</span><span class="p">)</span>

<span class="c1"># 根据平台注入</span>
<span class="k">func</span> <span class="nf">_setup_input</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">OS</span><span class="o">.</span><span class="n">is_mobile</span><span class="p">():</span>
        <span class="n">player</span><span class="o">.</span><span class="n">input_service</span> <span class="o">=</span> <span class="n">MobileInputService</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">player</span><span class="o">.</span><span class="n">input_service</span> <span class="o">=</span> <span class="n">PCInputService</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
</code></pre></div></div> <hr/> <h3 id="四godot-依赖注入最佳实践"><strong>四、Godot 依赖注入最佳实践</strong></h3> <h4 id="1-接口抽象"><strong>1. 接口抽象</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># IAnalyticsService.gd</span>
<span class="k">extends</span> <span class="n">RefCounted</span>
<span class="k">class_name</span> <span class="n">IAnalyticsService</span>

<span class="k">func</span> <span class="nf">log_event</span><span class="p">(</span><span class="n">event_name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># 实现类</span>
<span class="k">class</span> <span class="nc">FirebaseAnalytics</span> <span class="k">extends</span> <span class="n">IAnalyticsService</span><span class="p">:</span>
    <span class="k">func</span> <span class="nf">log_event</span><span class="p">(</span><span class="n">event_name</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
        <span class="n">Firebase</span><span class="o">.</span><span class="n">Analytics</span><span class="o">.</span><span class="n">log_event</span><span class="p">(</span><span class="n">event_name</span><span class="p">)</span>
</code></pre></div></div> <h4 id="2-依赖容器"><strong>2. 依赖容器</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># DI Container</span>
<span class="k">var</span> <span class="n">services</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"analytics"</span><span class="p">:</span> <span class="n">FirebaseAnalytics</span><span class="o">.</span><span class="n">new</span><span class="p">(),</span>
    <span class="s2">"storage"</span><span class="p">:</span> <span class="n">CloudSaveService</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="nf">get_service</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">services</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="c1"># 使用端</span>
<span class="k">var</span> <span class="n">analytics</span> <span class="o">=</span> <span class="n">DIContainer</span><span class="o">.</span><span class="n">get_service</span><span class="p">(</span><span class="s2">"analytics"</span><span class="p">)</span>
<span class="n">analytics</span><span class="o">.</span><span class="n">log_event</span><span class="p">(</span><span class="s2">"game_start"</span><span class="p">)</span>
</code></pre></div></div> <h4 id="3-自动注入工具"><strong>3. 自动注入工具</strong></h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 通过特性标记自动注入</span>
<span class="k">class_name</span> <span class="n">Injectable</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">di_key</span><span class="p">:</span> <span class="kt">String</span>

<span class="k">func</span> <span class="nf">_enter_tree</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">DIContainer</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">di_key</span><span class="p">):</span>
        <span class="n">set</span><span class="p">(</span><span class="n">di_key</span><span class="p">,</span> <span class="n">DIContainer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">di_key</span><span class="p">))</span>

<span class="c1"># 使用</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">analytics</span><span class="p">:</span> <span class="n">IAnalyticsService</span><span class="p">:</span>
    <span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">analytics</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">add_to_group</span><span class="p">(</span><span class="s2">"injectable"</span><span class="p">,</span> <span class="bp">true</span><span class="p">)</span>
</code></pre></div></div> <hr/> <h3 id="五与传统方式的性能对比"><strong>五、与传统方式的性能对比</strong></h3> <p>| <strong>指标</strong> | <strong>常规方式</strong> | <strong>依赖注入</strong> | |—————-|————-|————-| | 代码耦合度 | 高 (⭐) | 低 (⭐⭐⭐⭐⭐) | | 可测试性 | 差 | 优 | | 启动时间 | 快 | 略慢(+5-10%)| | 内存占用 | 低 | 略高(+3-8%) | | 多平台适配成本 | 高 | 低 |</p> <hr/> <h3 id="六适用场景决策树"><strong>六、适用场景决策树</strong></h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>是否需要以下特性？
├─ 单元测试 → 需要DI
├─ 多平台构建 → 需要DI  
├─ 模块热替换 → 需要DI
├─ 长期维护 → 需要DI
└─ 快速原型 → 传统方式更合适
</code></pre></div></div> <p>依赖注入在 Godot 中特别适合中大型项目，通过解耦实现更好的架构控制。对于小型项目，直接使用 <code class="language-plaintext highlighter-rouge">get_node()</code> 和单例仍是合理选择。关键在于根据项目规模灵活选择架构方案。</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="Godot"/><category term="GDScript"/><category term="note"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">手册学习之最佳实践</title><link href="https://uifj.github.io/blog/2025/%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="alternate" type="text/html" title="手册学习之最佳实践"/><published>2025-04-02T00:00:00+00:00</published><updated>2025-04-02T00:00:00+00:00</updated><id>https://uifj.github.io/blog/2025/%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5</id><content type="html" xml:base="https://uifj.github.io/blog/2025/%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://docs.godotengine.org/  基于官方文档4.4
</code></pre></div></div> <h2 id="一最佳实践">一、最佳实践</h2> <p>==前言：依赖于<strong>面向对象</strong>设计原则，使用<strong>单一职责</strong>和<strong>封装方法</strong>==</p> <h3 id="1面向对象设计原则">1.面向对象设计原则</h3> <p>简单来说，就是将客观世界存在或不存在的概念通过抽象成一个个的个体，通过使用编程操作这些对象。</p> <p>关键概念：<strong>对象是类的实例。</strong> 三大特征：<strong>封装、继承、多态</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>封装就是将类中的需求拆分成其他类，继承就是继承父类拥有的内容，多态就是重写父类的内容。
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、特性、代码与方法。对象则指的是类（class）的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://blog.csdn.net/qq_16856917/article/details/90384526 通过游戏设计的方式学习知识
</code></pre></div></div> <h3 id="2单一职责原则">2.单一职责原则</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Single Responsibility Principle, SRP) 单一职责要求：**一个类或模块应该有且只有一个引起它变化的原因**。
</code></pre></div></div> <p><strong>下面的代码的问题：​</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">Player</code> 类同时负责管理玩家的健康值和绘制血条的界面逻辑。</li> <li>如果未来需要修改血条样式或健康值的计算方式，都需要修改同一个类，增加了耦合性。 <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 玩家类，同时管理数据和界面逻辑</span>
<span class="k">class</span> <span class="nc">Player</span><span class="p">:</span>
  <span class="k">var</span> <span class="n">health</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">100</span>

  <span class="c1"># 处理伤害</span>
  <span class="k">func</span> <span class="nf">take_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
      <span class="n">health</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">health</span> <span class="o">-</span> <span class="n">amount</span><span class="p">)</span>

  <span class="c1"># 绘制血条到屏幕（界面逻辑）</span>
  <span class="k">func</span> <span class="nf">draw_health_bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">"绘制血条："</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">health</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"/100"</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> <p><strong>遵循 SRP 的改进：​</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">Player</code> 类只管理数据，<code class="language-plaintext highlighter-rouge">HealthUI</code> 类只处理显示逻辑。</li> <li>修改血条样式不会影响玩家数据逻辑，反之亦然。</li> </ul> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 玩家类，同时管理数据和界面逻辑</span>
<span class="k">class</span> <span class="nc">Player</span><span class="p">:</span>
	<span class="k">var</span> <span class="n">health</span> <span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">100</span>
	
	<span class="c1"># 处理伤害</span>
	<span class="k">func</span> <span class="nf">take_demage</span><span class="p">(</span><span class="n">amount</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span><span class="n">void</span><span class="p">:</span>
		<span class="n">health</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">health</span> <span class="o">-</span> <span class="n">amount</span><span class="p">)</span>

	<span class="c1"># 绘制血条到屏幕(页面逻辑)</span>
	<span class="k">func</span> <span class="nf">draw_health_bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"绘制血条:"</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">health</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"/100"</span><span class="p">)</span>
</code></pre></div></div> <p><strong>单一职责，推荐通过组合的方式，将不同的类结合起来，避免过高的耦合。</strong></p> <h3 id="2封装">2.封装</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>是面向对象编程的核心概念之一，重点在于： 1. 将数据与操作数据的方法绑定。 2. 限制从外部直接访问操作对象内部的数据。
</code></pre></div></div> <p><strong>未封装的代码问题：​</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">health</code> 直接暴露，外部可能赋予非法值（如负数）。 ``` gdscript class Player: var health: int = 100</li> </ul> <h1 id="外部可以直接修改-health可能导致非法值">外部可以直接修改 health，可能导致非法值</h1> <p>var player = Player.new() player.health = -50 # 非法值，但无约束</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

**通过封装改进的代码：​**
- `_health` 被设为“私有”（GDScript 中通过 `_` 前缀约定），外部无法直接修改。
- 必须通过 `take_damage` 方法修改值，确保数值合法性（如伤害值必须为正数）。
- 通过 `get_health` 方法提供只读访问。

```gdscript
class Player:
    var _health: int = 100  # 私有变量（约定以 _ 开头）

    # 通过方法控制伤害逻辑
    func take_damage(amount: int) -&gt; void:
        if amount &gt; 0:
            _health = max(0, _health - amount)

    # 提供只读访问
    func get_health() -&gt; int:
        return _health

# 使用封装的 Player 类
var player = Player.new()
player.take_damage(30)
print(player.get_health())  # 输出 70
# player._health = -10  # 无法直接访问（约定私有）
</code></pre></div></div> <h3 id="3单一职责与封装的结合">3.单一职责与封装的结合</h3> <p><strong>结合 SRP 和封装：</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">PlayerData</code> 类只负责管理数据，并通过封装保护 <code class="language-plaintext highlighter-rouge">_health</code>。</li> <li><code class="language-plaintext highlighter-rouge">PlayerUI</code> 类只负责显示逻辑。</li> <li>两者职责明确，且数据访问受控</li> </ul> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 玩家数据类（SRP + 封装）</span>
<span class="k">class</span> <span class="nc">PlayerData</span><span class="p">:</span>
    <span class="k">var</span> <span class="n">_health</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="k">func</span> <span class="nf">take_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_health</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_health</span> <span class="o">-</span> <span class="n">amount</span><span class="p">)</span>

    <span class="k">func</span> <span class="nf">get_health</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_health</span>

<span class="c1"># 玩家界面类（SRP）</span>
<span class="k">class</span> <span class="nc">PlayerUI</span><span class="p">:</span>
    <span class="k">static</span> <span class="k">func</span> <span class="nf">update_health_display</span><span class="p">(</span><span class="n">player_data</span><span class="p">:</span> <span class="n">PlayerData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"当前生命值："</span><span class="p">,</span> <span class="n">player_data</span><span class="o">.</span><span class="n">get_health</span><span class="p">())</span>

<span class="c1"># 使用示例</span>
<span class="k">var</span> <span class="n">player_data</span> <span class="o">=</span> <span class="n">PlayerData</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="k">var</span> <span class="n">player_ui</span> <span class="o">=</span> <span class="n">PlayerUI</span>

<span class="n">player_data</span><span class="o">.</span><span class="n">take_damage</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">player_ui</span><span class="o">.</span><span class="n">update_health_display</span><span class="p">(</span><span class="n">player_data</span><span class="p">)</span>  <span class="c1"># 输出 "当前生命值：80"</span>
</code></pre></div></div> <h3 id="4-godot中面向对象的使用">4. godot中面向对象的使用</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Godot 引擎主要提供了两种创建可复用对象的方式：脚本和场景。
</code></pre></div></div> <h4 id="脚本script">脚本Script</h4> <p>引擎提供了内置的类，如 <a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_node.html#class-node">Node</a> 。你可以使用脚本<strong>script</strong>扩展这些类来创建派生类型，而<strong>脚本script</strong>是一种资源文件，用来告知引擎在某一内置类的基础上执行一系列初始化。</p> <p>Godot 的内部类可以将一个类的数据注册进一个名为 <a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_classdb.html#class-classdb">ClassDB</a> 的数据库，该数据库让我们可以在运行时访问类的信息。<code class="language-plaintext highlighter-rouge">ClassDB</code> 包含有关类的信息，例如：</p> <ul> <li>属性。</li> <li>方法。</li> <li>常量。</li> <li>信号。</li> </ul> <h4 id="场景scence">场景Scence：</h4> <p>场景的行为与类有很多相似之处，所以把场景看成一个类也是合理的。 <strong>场景是可复用、可实例化、可继承的节点组。add_child( )方法可添加子节点。</strong> 场景Scence 用于组织节点，而节点又是对象，所以<strong>场景的实例都是对象。</strong></p> <p>==场景就是对附着在根节点上的<strong>脚本的扩展</strong>，所以你可以将其解释为类的一部分。==</p> <h3 id="5场景组织scence">5.场景组织Scence</h3> <h4 id="核心设计原则">核心设计原则</h4> <ol> <li>​<strong>松耦合（Loose Coupling）​</strong> <ul> <li>子节点不直接暴露访问点，由父节点中介管理引用。</li> <li>节点应尽可能独立，减少对环境的依赖，便于重用。</li> </ul> </li> <li>​<strong>数据内部化（Data Encapsulation）​</strong> <ul> <li>关键数据应封装在场景内部，避免依赖外部上下文。</li> <li>通过工具脚本自动生成配置警告，减少文档维护。</li> </ul> </li> <li>​<strong>明确的入口点（Main 节点）​</strong> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">Main</code> 节点作为全局控制器，管理场景切换和核心逻辑。</li> </ul> </li> <li>​<strong>单例与自动加载（Singleton &amp; Autoload）​</strong> <ul> <li>全局系统（如游戏管理器）应定义为自动加载的单例。</li> </ul> </li> <li>​<strong>节点树逻辑优先</strong> <ul> <li>根据逻辑关系（而非空间位置）组织节点，避免不必要的父子依赖。</li> </ul> </li> </ol> <h4 id="建立有效的关系">建立有效的关系</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>由于场景通常容易充满各种节点内容，所以如何建立组织关系很重要。
</code></pre></div></div> <p><strong>OOP编程中，需要保持松散的耦合，提高重用性。</strong> 如果可以，尽量设计没有依赖关系的场景。</p> <p>如果场景必须与外部环境交互，那么有下面5种方式进行操作：</p> <ol> <li><strong>连接信号。</strong> 缺点在于只能“响应”内容。信号名称通常是过去式动词，如“entered”“skill_activated”“item_collected”（已进入、已激活技能、已收集道具）。</li> <li><strong>调用方法。</strong></li> <li><strong>初始化Callable属性。</strong> Callable代表一个方法或一个独立函数的内置类型。</li> <li><strong>初始化Node或其他Object的引用。</strong></li> <li><strong>初始化NodePath。</strong></li> </ol> <p>此外，有经验后，更推荐使用<strong>依赖注入</strong>的方式去使用。</p> <h4 id="选择节点树结构">选择节点树结构</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>使用一个 Main节点作为入口节点。
</code></pre></div></div> <h4 id="代码示例">代码示例：</h4> <h5 id="51-松耦合父节点中介通信">5.1. 松耦合：父节点中介通信</h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Parent 节点（parent.gd）</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="err">@</span><span class="k">onready</span> <span class="k">var</span> <span class="n">left</span> <span class="o">=</span> <span class="o">$</span><span class="n">Left</span>
<span class="err">@</span><span class="k">onready</span> <span class="k">var</span> <span class="n">right</span> <span class="o">=</span> <span class="o">$</span><span class="n">Right</span><span class="o">/</span><span class="n">Receiver</span>

<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="n">left</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">right</span>  <span class="c1"># 父节点传递引用</span>


<span class="c1"># Left 节点（left.gd）</span>
<span class="k">extends</span> <span class="n">Node</span>
<span class="k">var</span> <span class="n">target</span><span class="p">:</span> <span class="n">Node</span>

<span class="k">func</span> <span class="nf">execute</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
        <span class="n">target</span><span class="o">.</span><span class="n">do_something</span><span class="p">()</span>  <span class="c1"># 通过父节点中介调用</span>


<span class="c1"># Right/Receiver 节点（receiver.gd）</span>
<span class="k">extends</span> <span class="n">Node</span>
<span class="k">func</span> <span class="nf">do_something</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Right 节点被调用"</span><span class="p">)</span>
</code></pre></div></div> <h5 id="52-工具脚本自动生成配置警告">5.2. 工具脚本：自动生成配置警告</h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 子节点（需依赖父节点的组件）</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="k">func</span> <span class="nf">_get_configuration_warnings</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">PackedStringArray</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">get_parent</span><span class="p">()</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="s2">"RequiredComponent"</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">"需要父节点包含 RequiredComponent"</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div> <ul> <li>若父节点缺少 <code class="language-plaintext highlighter-rouge">RequiredComponent</code>，场景编辑器会显示警告图标。</li> </ul> <h5 id="53-main-节点与场景切换">5.3. Main 节点与场景切换</h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Main 节点（main.gd）</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="k">var</span> <span class="n">current_world</span><span class="p">:</span> <span class="n">Node</span>

<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="n">load_world</span><span class="p">(</span><span class="s2">"res://world_1.tscn"</span><span class="p">)</span>

<span class="k">func</span> <span class="nf">load_world</span><span class="p">(</span><span class="n">scene_path</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">current_world</span><span class="p">:</span>
        <span class="n">current_world</span><span class="o">.</span><span class="n">queue_free</span><span class="p">()</span>  <span class="c1"># 卸载旧场景</span>
    <span class="k">var</span> <span class="n">new_world</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="n">scene_path</span><span class="p">)</span><span class="o">.</span><span class="n">instantiate</span><span class="p">()</span>
    <span class="n">add_child</span><span class="p">(</span><span class="n">new_world</span><span class="p">)</span>
    <span class="n">current_world</span> <span class="o">=</span> <span class="n">new_world</span>
</code></pre></div></div> <h5 id="54-单例自动加载global-系统">5.4. 单例自动加载（Global 系统）</h5> <ol> <li>创建 <code class="language-plaintext highlighter-rouge">global.gd</code>，在 ​<strong>Project Settings &gt; Autoload</strong> 添加为单例。</li> </ol> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># global.gd</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="k">var</span> <span class="n">score</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">func</span> <span class="nf">add_score</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="n">score</span> <span class="o">+=</span> <span class="n">value</span>
</code></pre></div></div> <h5 id="55-避免父子依赖使用top_level">5.5. 避免父子依赖：使用 <code class="language-plaintext highlighter-rouge">top_level</code></h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 子节点忽略父节点变换</span>
<span class="k">extends</span> <span class="n">Sprite2D</span>

<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="n">top_level</span> <span class="o">=</span> <span class="bp">true</span>  <span class="c1"># 独立于父节点的位置</span>
</code></pre></div></div> <h5 id="56-依赖注入的方式">5.6. 依赖注入的方式</h5> <hr/> <h4 id="关键实践">关键实践</h4> <ol> <li>​<strong>场景独立工作能力</strong> <ul> <li>每个场景应能独立运行（通过工具脚本检查依赖）。</li> </ul> </li> <li>​<strong>节点移动策略</strong> <ul> <li>切换场景时，关键节点（如玩家）可暂时移动到 <code class="language-plaintext highlighter-rouge">Main</code> 节点下： <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 切换房间前保留玩家</span>
<span class="k">var</span> <span class="n">player</span> <span class="o">=</span> <span class="n">current_room</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">"Player"</span><span class="p">)</span>
<span class="n">remove_child</span><span class="p">(</span><span class="n">current_room</span><span class="p">)</span>
<span class="n">player</span><span class="o">.</span><span class="n">reparent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># 移动到 Main 节点</span>
<span class="n">current_room</span><span class="o">.</span><span class="n">queue_free</span><span class="p">()</span>
</code></pre></div> </div> </li> </ul> </li> <li>​<strong>网络游戏结构</strong> <ul> <li>分离客户端和服务端逻辑节点，避免冗余数据同步。</li> </ul> </li> <li>​<strong>声明式解耦</strong> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">Node</code> 作为中间层，阻断不必要的变换继承。</li> </ul> </li> </ol> <h4 id="设计哲学">设计哲学</h4> <ul> <li>​<strong>SOLID 原则</strong>：尤其是单一职责（<code class="language-plaintext highlighter-rouge">Main</code>、<code class="language-plaintext highlighter-rouge">World</code>、<code class="language-plaintext highlighter-rouge">GUI</code> 分离）。</li> <li>​<strong>DRY</strong>：通过单例和父节点中介复用逻辑。</li> <li>​<strong>KISS/YAGNI</strong>：避免过度设计，按需实现功能。</li> </ul> <h3 id="6怎么选择场景与脚本">6.怎么选择场景与脚本</h3> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">MyNode</span> <span class="o">=</span> <span class="nb">preload</span><span class="p">(</span><span class="s2">"my_node.gd"</span><span class="p">)</span>
<span class="k">const</span> <span class="n">MyScene</span> <span class="o">=</span> <span class="nb">preload</span><span class="p">(</span><span class="s2">"my_scene.tscn"</span><span class="p">)</span>
<span class="k">var</span> <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="k">var</span> <span class="n">my_node</span> <span class="o">=</span> <span class="n">MyNode</span><span class="o">.</span><span class="n">new</span><span class="p">()</span> <span class="c1"># Same method call.</span>
<span class="k">var</span> <span class="n">my_scene</span> <span class="o">=</span> <span class="n">MyScene</span><span class="o">.</span><span class="n">instantiate</span><span class="p">()</span> <span class="c1"># Different method call.</span>
<span class="k">var</span> <span class="n">my_inherited_scene</span> <span class="o">=</span> <span class="n">MyScene</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">PackedScene</span><span class="o">.</span><span class="n">GEN_EDIT_STATE_MAIN</span><span class="p">)</span> <span class="c1"># Create scene inheriting from MyScene.</span>
</code></pre></div></div> <p>由于引擎和脚本Script代码之间的速度差异, 脚本的运行速度将比场景慢一些. 节点越大和越复杂, 将它构建为场景。</p> <p>脚本和场景之间，更推荐创建<strong>场景</strong>。</p> <p>==相比于直接在Script中创建节点Node，使用场景的<strong>PackedScene</strong>有助于避免这个性能问题。PackedScene（场景包）是场景继承的基础类型，定义了使用序列化数据创建对象的资源。==</p> <h4 id="脚本script与场景scence的适用场景">脚本Script与场景Scence的适用场景</h4> <ol> <li>​<strong>可重用工具</strong> - 应使用<strong>脚本</strong>，并添加 <code class="language-plaintext highlighter-rouge">class_name</code> 自定义类名和图标，全局可见，便于跨项目复用。 <ul> <li>轻量级，适合提供通用功能（如工具类、算法库）。</li> </ul> </li> <li>​<strong>特定游戏概念</strong> - 应使用<strong>场景</strong>，便于可视化编辑，数据更安全（节点属性可配置）。 <ul> <li>适合游戏实体（如角色、UI界面）、关卡设计、节点树结构清晰。</li> </ul> </li> <li>​<strong>通过脚本类命名场景</strong> - 在脚本中预加载场景并定义为常量，使其像类一样被引用。 <ul> <li>提高代码可读性，避免硬编码路径（推荐类名，避免路径字符串）。</li> </ul> </li> </ol> <h4 id="代码示例-1">代码示例</h4> <h5 id="61-可重用工具脚本">6.1. ​<strong>可重用工具脚本</strong></h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># math_utils.gd（工具脚本）</span>
<span class="err">@</span><span class="k">tool</span> <span class="c1"># 允许在编辑器中运行</span>
<span class="k">class_name</span> <span class="n">MathUtils</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="c1"># 自定义图标（在脚本属性中设置）</span>
<span class="k">static</span> <span class="k">func</span> <span class="nf">clamp_value</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="kt">float</span><span class="p">,</span> <span class="n">min_val</span><span class="p">:</span> <span class="kt">float</span><span class="p">,</span> <span class="n">max_val</span><span class="p">:</span> <span class="kt">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">clamp</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">)</span>
</code></pre></div></div> <h5 id="62-游戏专属场景">6.2. ​<strong>游戏专属场景</strong></h5> <p>创建 <code class="language-plaintext highlighter-rouge">player.tscn</code> 场景：</p> <ul> <li>包含 <code class="language-plaintext highlighter-rouge">CharacterBody2D</code> 节点、碰撞体、精灵等。</li> <li>导出属性（如移动速度）供非程序员在编辑器调整。</li> </ul> <h5 id="63-通过脚本类引用场景">6.3. ​<strong>通过脚本类引用场景</strong></h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># game_concepts.gd（定义场景常量）</span>
<span class="k">class_name</span> <span class="n">GameConcepts</span>
<span class="k">extends</span> <span class="n">RefCounted</span>

<span class="k">const</span> <span class="n">PlayerScene</span> <span class="o">=</span> <span class="nb">preload</span><span class="p">(</span><span class="s2">"res://player.tscn"</span><span class="p">)</span>
<span class="k">const</span> <span class="n">EnemyScene</span> <span class="o">=</span> <span class="nb">preload</span><span class="p">(</span><span class="s2">"res://enemy.tscn"</span><span class="p">)</span>

<span class="c1"># main.gd（主脚本）</span>
<span class="k">extends</span> <span class="n">Node</span>
<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="k">var</span> <span class="n">player</span> <span class="o">=</span> <span class="n">GameConcepts</span><span class="o">.</span><span class="n">PlayerScene</span><span class="o">.</span><span class="n">instantiate</span><span class="p">()</span>
    <span class="n">add_child</span><span class="p">(</span><span class="n">player</span><span class="p">)</span>
</code></pre></div></div> <h3 id="7自动加载autodload与常规节点">7.自动加载（Autodload）与常规节点</h3> <h4 id="自动加载">自动加载</h4> <ol> <li>​<strong>优点</strong> <ul> <li>​<strong>全局访问</strong>：适用于需要在多个场景间共享的系统（如任务、对话系统）。</li> <li>​<strong>简化代码</strong>：避免重复初始化通用功能（如存档管理、全局配置）。</li> </ul> </li> <li>​<strong>缺点</strong> <ul> <li>​<strong>全局状态</strong>：可能导致耦合性高，难以追踪错误。</li> <li>​<strong>资源浪费</strong>：预分配资源可能占用内存（如音频节点池）。</li> <li>​<strong>违反封装</strong>：其他场景可能直接修改全局数据，破坏安全性。</li> </ul> </li> </ol> <p>==<strong>解决方案</strong>（避免滥用自动加载）==</p> <ol> <li>​<strong>场景内部管理</strong>：每个场景自行管理资源（如音效播放器）。</li> <li>​<strong>静态工具类</strong>：通过 <code class="language-plaintext highlighter-rouge">class_name</code> + <code class="language-plaintext highlighter-rouge">static</code> 方法共享功能，无需实例化。</li> <li>​<strong>资源文件</strong>：用 <code class="language-plaintext highlighter-rouge">Resource</code> 类型共享数据（如游戏配置）。</li> </ol> <h4 id="代码示例-2">代码示例</h4> <h5 id="71-自动加载的正确使用全局任务系统">7.1. ​<strong>自动加载的正确使用：全局任务系统</strong></h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># autoloads/task_manager.gd</span>
<span class="k">class_name</span> <span class="n">TaskManager</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="k">var</span> <span class="n">active_tasks</span><span class="p">:</span> <span class="kt">Array</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">func</span> <span class="nf">add_task</span><span class="p">(</span><span class="n">task_name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
    <span class="n">active_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task_name</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"任务添加:"</span><span class="p">,</span> <span class="n">task_name</span><span class="p">)</span>

<span class="c1"># 在其他场景中调用</span>
<span class="n">TaskManager</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">"击败BOSS"</span><span class="p">)</span>
</code></pre></div></div> <h5 id="72-场景内部管理音效避免全局状态">7.2. ​<strong>场景内部管理音效（避免全局状态）​</strong></h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># scene_with_sound.tscn 的脚本</span>
<span class="k">extends</span> <span class="n">Node2D</span>

<span class="err">@</span><span class="k">onready</span> <span class="k">var</span> <span class="n">audio_players</span><span class="p">:</span> <span class="kt">Array</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">$</span><span class="n">AudioStreamPlayer1</span><span class="p">,</span>
    <span class="o">$</span><span class="n">AudioStreamPlayer2</span>
<span class="p">]</span>

<span class="k">func</span> <span class="nf">play_sound</span><span class="p">(</span><span class="n">sound_path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">void</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">player</span> <span class="ow">in</span> <span class="n">audio_players</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">player</span><span class="o">.</span><span class="n">playing</span><span class="p">:</span>
            <span class="n">player</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="n">sound_path</span><span class="p">)</span>
            <span class="n">player</span><span class="o">.</span><span class="n">play</span><span class="p">()</span>
            <span class="k">break</span>

<span class="c1"># 调用示例（仅在当前场景内）</span>
<span class="n">play_sound</span><span class="p">(</span><span class="s2">"res://coin_pickup.ogg"</span><span class="p">)</span>
</code></pre></div></div> <h5 id="73-静态工具类替代自动加载">7.3. ​<strong>静态工具类替代自动加载</strong></h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># math_utils.gd（工具类，无需自动加载）</span>
<span class="k">class_name</span> <span class="n">MathUtils</span>
<span class="k">extends</span> <span class="kt">Object</span>  <span class="c1"># 无需继承Node，直接作为静态工具类</span>

<span class="k">static</span> <span class="k">func</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="kt">float</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="kt">float</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="kt">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="nb">clamp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># 调用示例</span>
<span class="k">var</span> <span class="n">value</span> <span class="o">=</span> <span class="n">MathUtils</span><span class="o">.</span><span class="nb">lerp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># 输出50</span>
</code></pre></div></div> <h5 id="74-资源文件共享数据">7.4. ​<strong>资源文件共享数据</strong></h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># game_config.gd（Resource类型）</span>
<span class="k">class_name</span> <span class="n">GameConfig</span>
<span class="k">extends</span> <span class="n">Resource</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">player_speed</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">300.0</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">volume</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">0.8</span>

<span class="c1"># 保存/加载配置</span>
<span class="k">var</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GameConfig</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="n">ResourceSaver</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="s2">"res://game_config.tres"</span><span class="p">)</span>
<span class="k">var</span> <span class="n">loaded_config</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="s2">"res://game_config.tres"</span><span class="p">)</span>
</code></pre></div></div> <h4 id="何时使用自动加载">何时使用自动加载？</h4> <table> <thead> <tr> <th>​<strong>场景</strong></th> <th>​<strong>推荐方案</strong></th> <th>​<strong>示例</strong></th> </tr> </thead> <tbody> <tr> <td>全局任务/对话系统</td> <td>自动加载</td> <td><code class="language-plaintext highlighter-rouge">TaskManager</code></td> </tr> <tr> <td>场景独立音效管理</td> <td>场景内部管理</td> <td>每个场景的 <code class="language-plaintext highlighter-rouge">audio_players</code></td> </tr> <tr> <td>数学工具类</td> <td>静态工具类（<code class="language-plaintext highlighter-rouge">static</code>）</td> <td><code class="language-plaintext highlighter-rouge">MathUtils</code></td> </tr> <tr> <td>共享配置数据</td> <td>资源文件（<code class="language-plaintext highlighter-rouge">Resource</code>）</td> <td><code class="language-plaintext highlighter-rouge">GameConfig</code></td> </tr> </tbody> </table> <h3 id="8避免任何时候使用节点node性能优化">8.避免任何时候使用节点Node（性能优化）</h3> <p>Godot 提供了三种更加轻量化的对象：</p> <ol> <li><a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_object.html#class-object">Object</a>：终极轻量级对象，原始的 Object 必须使用<strong>手动内存管理</strong>。参考<a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_tree.html#class-tree">Tree</a> 节点示例。</li> <li><a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_refcounted.html#class-refcounted">RefCounted</a>：只比 Object 稍微复杂一点。它们会记录对自己的引用，只有当对自己没有另外的引用存在时，才会删除加载的内存。参考<a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_fileaccess.html#class-fileaccess">FileAccess</a> 对象。</li> <li><a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_resource.html#class-resource">Resource</a> ：只比 RefCounted 稍微复杂一点。它们天然具有将其对象属性序列化（即保存）到 Godot 资源文件，或从 Godot 资源文件中反序列化（即加载）的能力。 参考<a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_audioeffect.html#class-audioeffect">AudioEffect</a> 类。<strong>相比传统存储数据更好，不仅轻量，而且兼容性还好。</strong></li> </ol> <p><strong>关键原则：</strong></p> <ol> <li>​<strong>优先轻量级对象</strong>： <ul> <li>如果不需要节点树、信号或物理特性，使用 <code class="language-plaintext highlighter-rouge">Object</code>/<code class="language-plaintext highlighter-rouge">RefCounted</code>/<code class="language-plaintext highlighter-rouge">Resource</code>。</li> </ul> </li> <li>​<strong>减少节点数量</strong>： <ul> <li>避免为纯数据或工具逻辑创建节点。</li> </ul> </li> <li>​<strong>利用 <code class="language-plaintext highlighter-rouge">Resource</code> 的序列化</strong>： <ul> <li>将配置、预制体等数据保存为 <code class="language-plaintext highlighter-rouge">.tres</code> 文件，方便编辑和复用。</li> </ul> </li> </ol> <h4 id="代码示例-3">代码示例</h4> <h5 id="81object最轻量级的基础类"> <strong>8.1.<code class="language-plaintext highlighter-rouge">Object</code>：最轻量级的基础类</strong></h5> <ul> <li>​<strong>适用场景</strong>：需要自定义数据结构，无需节点功能（如树结构、生命周期方法）。</li> <li>​<strong>特点</strong>： <ul> <li>手动内存管理（需调用 <code class="language-plaintext highlighter-rouge">free()</code>）。</li> <li>适合底层逻辑（如数据模型、工具类）。</li> </ul> </li> </ul> <p><strong>GDScript 示例：​</strong></p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 自定义数据类（继承 Object）</span>
<span class="k">class_name</span> <span class="n">DataModel</span>
<span class="k">extends</span> <span class="kt">Object</span>

<span class="k">var</span> <span class="n">id</span><span class="p">:</span> <span class="kt">int</span>
<span class="k">var</span> <span class="n">name</span><span class="p">:</span> <span class="kt">String</span>

<span class="k">func</span> <span class="nf">_init</span><span class="p">(</span><span class="n">p_id</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">p_name</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">p_id</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">p_name</span>

<span class="c1"># 使用示例</span>
<span class="k">var</span> <span class="n">model</span> <span class="o">=</span> <span class="n">DataModel</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"Player"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># 输出 "Player"</span>
<span class="n">model</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>       <span class="c1"># 手动释放内存</span>
</code></pre></div></div> <hr/> <h5 id="8-2refcounted自动内存管理的引用计数类"> <strong>8. 2. <code class="language-plaintext highlighter-rouge">RefCounted</code>：自动内存管理的引用计数类</strong></h5> <ul> <li>​<strong>适用场景</strong>：需要自动内存管理，但无需序列化或编辑器集成。</li> <li>​<strong>特点</strong>： <ul> <li>自动释放内存（引用计数归零时）。</li> <li>适合临时数据容器或工具类。</li> </ul> </li> </ul> <p><strong>GDScript 示例：​</strong></p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 引用计数类（继承 RefCounted）</span>
<span class="k">class_name</span> <span class="n">GameTimer</span>
<span class="k">extends</span> <span class="n">RefCounted</span>

<span class="k">var</span> <span class="n">start_time</span><span class="p">:</span> <span class="kt">int</span>

<span class="k">func</span> <span class="nf">start</span><span class="p">():</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">get_ticks_msec</span><span class="p">()</span>

<span class="k">func</span> <span class="nf">get_elapsed_time</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Time</span><span class="o">.</span><span class="n">get_ticks_msec</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>

<span class="c1"># 使用示例</span>
<span class="k">var</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">GameTimer</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="n">timer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">timer</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">())</span>  <span class="c1"># 输出经过的毫秒数</span>
<span class="c1"># 无需手动调用 free()</span>
</code></pre></div></div> <h5 id="83resource可序列化的数据类"> <strong>8.​3. <code class="language-plaintext highlighter-rouge">Resource</code>：可序列化的数据类</strong></h5> <ul> <li>​<strong>适用场景</strong>：需要保存/加载数据，或在编辑器暴露属性。</li> <li>​<strong>特点</strong>： <ul> <li>支持序列化（保存为 <code class="language-plaintext highlighter-rouge">.tres</code> 文件）。</li> <li>属性可在检查器中编辑。</li> <li>适合配置、技能数据、预制体等。</li> </ul> </li> </ul> <p><strong>GDScript 示例：​</strong></p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 游戏配置（继承 Resource）</span>
<span class="k">class_name</span> <span class="n">GameConfig</span>
<span class="k">extends</span> <span class="n">Resource</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">player_speed</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">300.0</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">volume</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">0.8</span>

<span class="c1"># 保存配置</span>
<span class="k">func</span> <span class="nf">save_config</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
    <span class="n">ResourceSaver</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

<span class="c1"># 使用示例</span>
<span class="k">var</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GameConfig</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">player_speed</span> <span class="o">=</span> <span class="mf">350.0</span>
<span class="n">config</span><span class="o">.</span><span class="n">save_config</span><span class="p">(</span><span class="s2">"res://game_config.tres"</span><span class="p">)</span>
</code></pre></div></div> <hr/> <h5 id="何时避免使用节点">​<strong>何时避免使用节点？</strong></h5> <table> <thead> <tr> <th>​<strong>场景</strong></th> <th>​<strong>替代方案</strong></th> <th>​<strong>示例</strong></th> </tr> </thead> <tbody> <tr> <td>纯数据存储（无可视化）</td> <td><code class="language-plaintext highlighter-rouge">Resource</code></td> <td>游戏配置、技能数据</td> </tr> <tr> <td>临时数据容器（无需树结构）</td> <td><code class="language-plaintext highlighter-rouge">RefCounted</code></td> <td>计时器、网络请求结果</td> </tr> <tr> <td>底层工具类（无需生命周期）</td> <td><code class="language-plaintext highlighter-rouge">Object</code></td> <td>数学工具、自定义数据结构</td> </tr> </tbody> </table> <h5 id="代码对比节点-vs-轻量级对象场景存储玩家数据">​<strong>代码对比：节点 vs 轻量级对象</strong>（场景：存储玩家数据）</h5> <p><strong>使用节点（低效）：​</strong></p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 节点方式（浪费性能）</span>
<span class="k">class_name</span> <span class="n">PlayerDataNode</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="k">var</span> <span class="n">health</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">var</span> <span class="n">level</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div> <p><strong>使用 <code class="language-plaintext highlighter-rouge">Resource</code>（高效且可序列化）：​</strong></p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Resource 方式</span>
<span class="k">class_name</span> <span class="n">PlayerData</span>
<span class="k">extends</span> <span class="n">Resource</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">health</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">100</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">level</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div> <h3 id="9godot接口">9.Godot接口</h3> <h4 id="关键原则"><strong>关键原则</strong></h4> <ol> <li>​<strong>引用获取</strong> <ul> <li>优先使用 <code class="language-plaintext highlighter-rouge">@onready</code> 缓存节点，避免动态查找。</li> <li>复杂依赖用 <code class="language-plaintext highlighter-rouge">@export</code> 在编辑器配置，而非硬编码路径。</li> </ul> </li> <li>​<strong>数据访问</strong> <ul> <li>鸭子类型灵活但危险，必要时用 <code class="language-plaintext highlighter-rouge">has_method</code> 或类型断言保护。</li> <li>全局数据用自动加载，场景数据用 <code class="language-plaintext highlighter-rouge">Resource</code>。</li> </ul> </li> <li>​<strong>解耦设计</strong> <ul> <li>使用 Callable 或信号（<code class="language-plaintext highlighter-rouge">Signal</code>）减少直接依赖。</li> <li>通过组（Group）或命名约定实现松散耦合。</li> </ul> </li> </ol> <h4 id="获取对象引用就是操作该对象">获取对象引用（就是操作该对象）</h4> <ul> <li>​<strong>直接属性/方法访问</strong>：编辑器阶段加载，适合静态资源。</li> </ul> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 适用于Node 、Resource 和 RefCounted 这些类</span>
<span class="k">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">object</span> <span class="c1"># Property access. 访问节点的属性</span>
<span class="k">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_object</span><span class="p">()</span> <span class="c1"># Method access. 访问节点的方法</span>

</code></pre></div></div> <ul> <li>​<strong>预加载</strong>：编辑器阶段加载，适合静态资源。</li> <li>​<strong>动态加载</strong>：运行时加载，适合动态资源。 ``` gdscript <h1 id="预加载场景脚本编辑器阶段">预加载场景/脚本（编辑器阶段）</h1> <p>const MyScene = preload(“res://my_scene.tscn”) const MyScript = preload(“res://my_script.gd”)</p> </li> </ul> <h1 id="运行时动态加载">运行时动态加载</h1> <p>var dynamic_resource = load(“res://dynamic_data.tres”)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- ​**避免动态查找**：使用 `@onready` 缓存节点引用。
``` gdscript
# 慢：动态查找（每帧调用性能差）
func _process(delta):
    print(get_node("ChildNode"))

# 快：缓存引用
@onready var child_node = $ChildNode
func _process(delta):
    print(child_node)
</code></pre></div></div> <ul> <li>​<strong>适用场景</strong>：通过检查器Interceptor配置节点依赖。导出变量（Editor 配置） <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">enemy</span><span class="p">:</span> <span class="n">Node</span>  <span class="c1"># 在编辑器中拖拽赋值</span>
<span class="k">func</span> <span class="nf">attack</span><span class="p">():</span>
  <span class="k">if</span> <span class="n">enemy</span><span class="p">:</span>
      <span class="n">enemy</span><span class="o">.</span><span class="n">take_damage</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div> </div> </li> <li>​<strong>适用场景</strong>：全局管理器（如游戏状态、音效），全局自动加载（单例）​。 ``` gdscript <h1 id="autoloadsglobalgd">autoloads/global.gd</h1> <p>var score: int = 0</p> </li> </ul> <h1 id="其他脚本中访问">其他脚本中访问</h1> <p>func add_score(): Global.score += 10</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

#### 访问数据或逻辑
- ​**直接调用属性/方法**：不检查类型，运行时动态解析。（**Duck Typing**）
``` gdscript
# 假设目标节点有 `health` 属性和 `take_damage` 方法
var target = $Enemy
target.health -= 10      # 直接修改属性（可能报错）
target.take_damage(10)   # 直接调用方法（可能报错）
</code></pre></div></div> <ul> <li>​<strong>使用 <code class="language-plaintext highlighter-rouge">has_method</code> 或 <code class="language-plaintext highlighter-rouge">is_in_group</code></strong>：避免调用不存在的方法。（<strong>安全方法检查</strong>） <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">target</span> <span class="o">=</span> <span class="o">$</span><span class="n">Enemy</span>
<span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">has_method</span><span class="p">(</span><span class="s2">"take_damage"</span><span class="p">):</span>
  <span class="n">target</span><span class="o">.</span><span class="n">take_damage</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">is_in_group</span><span class="p">(</span><span class="s2">"enemies"</span><span class="p">):</span>
  <span class="n">target</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</code></pre></div> </div> </li> <li><strong>is 关键字</strong>：确保对象类型后再操作。<strong>类型断言（Type Casting）​</strong> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">target</span> <span class="o">=</span> <span class="o">$</span><span class="n">Enemy</span>
<span class="k">if</span> <span class="n">target</span> <span class="k">is</span> <span class="n">CharacterBody2D</span><span class="p">:</span>
 <span class="n">target</span><span class="o">.</span><span class="n">velocity</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">500</span>  <span class="c1"># 安全访问</span>
</code></pre></div> </div> </li> <li>​<strong>解耦调用</strong>：将方法动态绑定到外部。<strong>Callable 委托逻辑</strong> ``` gdscript <h1 id="子节点定义">子节点定义</h1> <p>class Child: var callback: Callable func execute(): if callback: callback.call()</p> </li> </ul> <h1 id="父节点绑定方法">父节点绑定方法</h1> <p>@onready var child = $Child func _ready(): child.callback = _on_child_execute func _on_child_execute(): print(“Child executed!”)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

#### 代码示例
#####  9.​1. 场景：攻击敌人
``` gdscript
# Enemy 节点脚本（enemy.gd）
extends CharacterBody2D

var health: int = 100

func take_damage(amount: int):
    health -= amount
    if health &lt;= 0:
        queue_free()

# Player 节点脚本（player.gd）
extends CharacterBody2D

@export var attack_target: Node  # 在编辑器中拖拽赋值

func _input(event):
    if event.is_action_pressed("attack"):
        if attack_target and attack_target.has_method("take_damage"):
            attack_target.take_damage(20)
</code></pre></div></div> <h5 id="92场景动态加载资源"> 9.​2. 场景：动态加载资源</h5> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 动态加载并实例化场景</span>
<span class="k">var</span> <span class="n">enemy_scene</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="s2">"res://enemy.tscn"</span><span class="p">)</span>
<span class="k">var</span> <span class="n">new_enemy</span> <span class="o">=</span> <span class="n">enemy_scene</span><span class="o">.</span><span class="n">instantiate</span><span class="p">()</span>
<span class="n">add_child</span><span class="p">(</span><span class="n">new_enemy</span><span class="p">)</span>
</code></pre></div></div> <h3 id="10godot通知与回调函数">10.Godot通知与回调函数</h3> <h4 id="常用回调函数"><strong>常用回调函数</strong></h4> <table> <thead> <tr> <th>​<strong>回调函数</strong></th> <th>​<strong>用途</strong></th> <th>​<strong>触发时机</strong></th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">_ready()</code></td> <td>节点及其子节点已完全初始化（场景树构建完成）</td> <td>节点首次加入场景树，且所有子节点已 <code class="language-plaintext highlighter-rouge">_ready</code> 后触发</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">_process(delta)</code></td> <td>每帧更新逻辑（依赖帧率，适合非物理逻辑）</td> <td>每帧触发（帧率不固定）</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">_physics_process(delta)</code></td> <td>物理更新逻辑（固定时间步长，适合物理计算）</td> <td>每物理帧触发（默认每秒 60 次）</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">_input(event)</code></td> <td>处理输入事件</td> <td>每输入事件触发（包括键盘、鼠标等）</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">_unhandled_input(event)</code></td> <td>处理未被其他节点处理的输入事件</td> <td>输入事件未被消费时触发</td> </tr> </tbody> </table> <h4 id="对比-init初始化导出">对比 init、初始化、导出</h4> <h5 id="_init">​<strong><code class="language-plaintext highlighter-rouge">_init()</code></strong></h5> <ul> <li>​<strong>用途</strong>：对象构造时初始化属性（无场景树依赖）。</li> <li>​<strong>触发时机</strong>：对象实例化时（节点未加入场景树）。</li> <li>​<strong>代码示例</strong>： ``` gdscript <h1 id="_init在_enter_tree或_ready之前触发但在脚本script创建并初始化其属性之后">_init() 在 _enter_tree() 或 _ready() 之前触发，但在脚本Script创建并初始化其属性之后。</h1> <p>@export var test: String = “one”: set(value): test = value + “!”</p> </li> </ul> <p>func _init(): # 在初始化属性之后，可以改变test的值，值将会变为‘two！’ . # 前面的Setter 函数在初始化后使用。 test = “two”</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
##### ​**导出变量初始化顺序**
1. 默认值赋值 → 2. `_init()` → 3. 导出值赋值（编辑器覆盖）。
- ​**代码示例**：
    ``` gdscript
    @export var speed: int = 50  # 默认值
    
    func _init():
        speed = 100  # 被 _init() 覆盖
    
    # 若在检查器Interceptor中设置 speed=200，最终值为 200
    ```
    

---

#### ​**3. 场景树生命周期**

|​**回调/通知**|​**用途**|​**代码示例**|
|---|---|---|
|`_enter_tree()`|节点加入场景树时触发（适合初始化依赖场景树的逻辑）|`gdscript func _enter_tree(): print("加入场景树")`|
|`_exit_tree()`|节点从场景树移除时触发（适合清理资源）|`gdscript func _exit_tree(): print("移除场景树")`|
|`NOTIFICATION_PARENTED`|节点被添加为子节点时触发（适合动态绑定父节点逻辑）|`gdscript func _notification(what): if what == NOTIFICATION_PARENTED: connect_to_parent()`|
|`NOTIFICATION_UNPARENTED`|节点被移除为子节点时触发（适合断开父节点连接）|`gdscript func _notification(what): if what == NOTIFICATION_UNPARENTED: disconnect_from_parent()`|

---

#### ​**4. 输入处理最佳实践**

- ​**避免在 `_process` 中检查输入**：每帧检查浪费性能。
- ​**使用 `_unhandled_input`**：仅在事件未被消费时触发。
- ​**代码示例**：
``` gdscript
# 每一帧都会执行，停止按键也会检查，所以有性能浪费
func _process(delta):
	if Input.is_action_just_pressed("ui_select"):
		print(delta)

# 只有在按键按下后才使用，性能很好
func _unhandled_input(event):
	match event.get_class():
		"InputEventKey":
			if Input.is_action_just_pressed("ui_accept"):
				print(get_process_delta_time())
</code></pre></div></div> <hr/> <h4 id="5-定时器替代高频_process">​<strong>5. 定时器替代高频 <code class="language-plaintext highlighter-rouge">_process</code></strong></h4> <p>“依赖于帧速率的 delta 时间增量”时，请使用 <code class="language-plaintext highlighter-rouge">_process</code>。但是，如果不需要每帧都执行，则可以选择用定时器循环来替代。</p> <ul> <li>​<strong>用途</strong>：减少每帧执行次数，优化性能。</li> <li>​<strong>代码示例</strong>： <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="err">@</span><span class="k">onready</span> <span class="k">var</span> <span class="n">timer</span> <span class="o">=</span> <span class="o">$</span><span class="n">Timer</span>
  <span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
      <span class="n">timer</span><span class="o">.</span><span class="n">wait_time</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># 每 0.5 秒触发</span>
      <span class="n">timer</span><span class="o">.</span><span class="n">timeout</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">_on_timer_timeout</span><span class="p">)</span>
      <span class="n">timer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    
  <span class="k">func</span> <span class="nf">_on_timer_timeout</span><span class="p">():</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">"定时任务执行"</span><span class="p">)</span>

  <span class="o">//</span> <span class="err">或者使用如下的方式</span>
  <span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
      <span class="k">var</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
      <span class="n">timer</span><span class="o">.</span><span class="n">autostart</span> <span class="o">=</span> <span class="bp">true</span>
      <span class="n">timer</span><span class="o">.</span><span class="n">wait_time</span> <span class="o">=</span> <span class="mf">0.5</span>
      <span class="n">add_child</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span>
      <span class="n">tiemr</span><span class="o">.</span><span class="n">timeout</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="k">func</span><span class="p">():</span>
          <span class="nb">print</span><span class="p">(</span><span class="s2">"This block runs every 0.5 seconds"</span><span class="p">)</span>
      <span class="p">)</span>
    

</code></pre></div> </div> </li> </ul> <hr/> <h4 id="6-父节点信号动态绑定">​<strong>6. 父节点信号动态绑定</strong></h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>当实例化脚本或独立的场景时，节点不会在创建时被添加到 SceneTree 中，所以未触发 `_enter_tree` 回调。而只有 `_init` 调用发生。当场景被添加到 SceneTree 时，才会调用 `_enter_tree` 和 `_ready`。
</code></pre></div></div> <ul> <li>​<strong>场景</strong>：节点被添加到父节点时自动连接信号。可以使用 <a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_node.html#class-node-constant-notification-parented">PARENTED</a> 通知</li> <li>​<strong>代码示例</strong>： ``` gdscript // 下面代码是将节点方法连接到其父节点上自定义信号, 并且不会失败的代码段。对可能在运行时创建并以数据为中心的节点很有用。 extends Node</li> </ul> <p>var parent_cache</p> <p>func connection_check(): return parent_cache.has_user_signal(“interacted_with”)</p> <p>func _notification(what): match what: NOTIFICATION_PARENTED: parent_cache = get_parent() if connection_check(): parent_cache.interacted_with.connect(_on_parent_interacted_with) NOTIFICATION_UNPARENTED: if connection_check(): parent_cache.interacted_with.disconnect(_on_parent_interacted_with)</p> <p>func _on_parent_interacted_with(): print(“I’m reacting to my parent’s interaction!”) ```</p> <h3 id="10数据偏好">10.数据偏好</h3> <h3 id="11逻辑偏好">11.逻辑偏好</h3> <h3 id="12-项目组织">12. 项目组织</h3> <h3 id="13版本控制系统">13.版本控制系统</h3>]]></content><author><name></name></author><category term="sample-posts"/><category term="Godot"/><category term="GDScript"/><category term="note"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">帆鸣_uifj_愚人节快乐！</title><link href="https://uifj.github.io/blog/2025/%E5%B8%86%E9%B8%A3_uifj/" rel="alternate" type="text/html" title="帆鸣_uifj_愚人节快乐！"/><published>2025-04-01T20:00:00+00:00</published><updated>2025-04-01T20:00:00+00:00</updated><id>https://uifj.github.io/blog/2025/%E5%B8%86%E9%B8%A3_uifj</id><content type="html" xml:base="https://uifj.github.io/blog/2025/%E5%B8%86%E9%B8%A3_uifj/"><![CDATA[<h1 id="呼唤">呼唤</h1> <p>愚人节快乐！！</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="charts"/><summary type="html"><![CDATA[迁移个人website]]></summary></entry><entry><title type="html">a post with plotly.js</title><link href="https://uifj.github.io/blog/2025/plotly/" rel="alternate" type="text/html" title="a post with plotly.js"/><published>2025-03-26T14:24:00+00:00</published><updated>2025-03-26T14:24:00+00:00</updated><id>https://uifj.github.io/blog/2025/plotly</id><content type="html" xml:base="https://uifj.github.io/blog/2025/plotly/"><![CDATA[<p>This is an example post with some <a href="https://plotly.com/javascript/">plotly</a> code.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">plotly
</span><span class="sb">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "type": "scatter"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [16, 5, 11, 9],
      "type": "scatter"
    }
  ]
}</span>
<span class="p">```</span>
</code></pre></div></div> <p>Which generates:</p> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "type": "scatter"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [16, 5, 11, 9],
      "type": "scatter"
    }
  ]
}
</code></pre> <p>Also another example chart.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">plotly
</span><span class="sb">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}</span>
<span class="p">```</span>
</code></pre></div></div> <p>This is how it looks like:</p> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}
</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="charts"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">a post with image galleries</title><link href="https://uifj.github.io/blog/2024/photo-gallery/" rel="alternate" type="text/html" title="a post with image galleries"/><published>2024-12-04T01:59:00+00:00</published><updated>2024-12-04T01:59:00+00:00</updated><id>https://uifj.github.io/blog/2024/photo-gallery</id><content type="html" xml:base="https://uifj.github.io/blog/2024/photo-gallery/"><![CDATA[<p>The images in this post are all zoomable, arranged into different mini-galleries using different libraries.</p> <h2 id="lightbox2"><a href="https://lokeshdhakar.com/projects/lightbox2/">Lightbox2</a></h2> <p><a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/></a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/></a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/></a></p> <hr/> <h2 id="photoswipe"><a href="https://photoswipe.com/">PhotoSwipe</a></h2> <div class="pswp-gallery pswp-gallery--single-column" id="gallery--getting-started"> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg" data-pswp-width="1669" data-pswp-height="2500" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg" alt=""/> </a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/7/img-2500.jpg" data-pswp-width="1875" data-pswp-height="2500" data-cropped="true" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/7/img-200.jpg" alt=""/> </a> <a href="https://unsplash.com" data-pswp-src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg" data-pswp-width="2500" data-pswp-height="1666" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg" alt=""/> </a> <div> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-2500.jpg" data-pswp-width="2500" data-pswp-height="1667" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-200.jpg" alt=""/> </a> </div> </div> <hr/> <h2 id="spotlight-js"><a href="https://nextapps-de.github.io/spotlight/">Spotlight JS</a></h2> <div class="spotlight-group"> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/> </a> </div> <div class="spotlight-group"> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/4/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/4/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/5/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/5/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-200.jpg"/> </a> </div> <hr/> <h2 id="venobox"><a href="https://veno.es/venobox/">Venobox</a></h2> <p><a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/></a> <a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/></a> <a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/></a></p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="images"/><summary type="html"><![CDATA[this is what included image galleries could look like]]></summary></entry></feed>