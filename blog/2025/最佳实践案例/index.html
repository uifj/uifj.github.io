<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 最佳实践案例 | 帆鸣_uifj </title> <meta name="author" content="The uifj"> <meta name="description" content="this is what included plotly.js code could look like"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://uifj.github.io/blog/2025/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> 帆鸣_uifj </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">关于我 </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">博客 </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">作品项目 </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">代码仓库 </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">简历 </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">UP主 </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">更多内容 </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">读书笔记</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/reports/">每月总结</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/tools/">高效工具</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/stories/">个人故事</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">最佳实践案例</h1> <p class="post-meta"> Created on April 11, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/godot"> <i class="fa-solid fa-hashtag fa-sm"></i> Godot</a>   <a href="/blog/tag/gdscript"> <i class="fa-solid fa-hashtag fa-sm"></i> GDScript</a>   <a href="/blog/tag/note"> <i class="fa-solid fa-hashtag fa-sm"></i> note</a>   ·   <a href="/blog/category/sample-posts"> <i class="fa-solid fa-tag fa-sm"></i> sample-posts</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="问题汇总1">问题汇总（1）</h2> <p>在Godot企业级游戏开发中，音频管理和存档系统的实现通常需要权衡代码的可维护性、可测试性和开发效率。以下是具体分析及实践方案：</p> <hr> <h3 id="1-音频管理系统"><strong>1. 音频管理系统</strong></h3> <h4 id="常用方案"><strong>常用方案</strong></h4> <p>• <strong>单例模式（AutoLoad）</strong> • <strong>实现方式</strong>：通过Godot的<code class="language-plaintext highlighter-rouge">AutoLoad</code>功能将<code class="language-plaintext highlighter-rouge">AudioManager</code>设为全局单例。 • <strong>优点</strong>： ◦ 快速访问音频接口，如<code class="language-plaintext highlighter-rouge">AudioManager.play_sound("shoot")</code>。 ◦ 集中管理音频资源、音量设置和播放队列。 • <strong>缺点</strong>： ◦ 全局状态可能引发隐式耦合，单元测试需依赖单例实例。 • <strong>适用场景</strong>：中小型项目，或需要高频全局访问的音频系统。</p> <p>• <strong>依赖注入（Dependency Injection）</strong> • <strong>实现方式</strong>： ◦ 在场景初始化时，将<code class="language-plaintext highlighter-rouge">AudioManager</code>实例作为参数传递给依赖它的节点。 ◦ 使用Godot的<code class="language-plaintext highlighter-rouge">@export</code>注解将管理器暴露到编辑器，手动拖拽赋值。 • <strong>优点</strong>： ◦ 明确依赖关系，便于替换实现（如静音模式或测试桩）。 ◦ 提高模块化，适合多人协作的大型项目。 • <strong>缺点</strong>： ◦ 增加初始化复杂度，需手动传递依赖。 • <strong>适用场景</strong>：需要严格解耦的企业级项目，或支持多平台差异化音频逻辑。</p> <hr> <h3 id="2-存档管理系统"><strong>2. 存档管理系统</strong></h3> <h4 id="常用方案-1"><strong>常用方案</strong></h4> <p>• <strong>单例模式（AutoLoad）</strong> • <strong>实现方式</strong>：将<code class="language-plaintext highlighter-rouge">SaveManager</code>设为AutoLoad单例，提供<code class="language-plaintext highlighter-rouge">save_game()</code>和<code class="language-plaintext highlighter-rouge">load_game()</code>接口。 • <strong>优点</strong>： ◦ 统一处理文件I/O、加密、版本迁移等底层逻辑。 ◦ 方便全局监听存档事件（如自动保存）。 • <strong>缺点</strong>： ◦ 存档逻辑与业务代码可能过度耦合。 • <strong>优化</strong>：通过<strong>观察者模式</strong>发送信号（如<code class="language-plaintext highlighter-rouge">save_completed</code>）解耦业务响应。</p> <p>• <strong>服务定位器模式</strong> • <strong>实现方式</strong>：通过一个全局的<code class="language-plaintext highlighter-rouge">ServiceLocator</code>提供<code class="language-plaintext highlighter-rouge">get_save_service()</code>，允许动态替换服务实现。 • <strong>优点</strong>： ◦ 兼顾全局访问的便利性和接口抽象（如本地存档 vs 云存档）。 ◦ 避免直接依赖具体类。 • <strong>适用场景</strong>：需要支持多种存档后端（如Steam云存档、本地文件）。</p> <hr> <h3 id="3-企业级开发中的关键实践"><strong>3. 企业级开发中的关键实践</strong></h3> <ol> <li> <p><strong>混合模式策略</strong> • <strong>核心系统用单例</strong>：如全局配置、存档、音频。 • <strong>业务模块用依赖注入</strong>：如将<code class="language-plaintext highlighter-rouge">AudioManager</code>注入到<code class="language-plaintext highlighter-rouge">Player</code>节点，而非直接调用全局变量。</p> </li> <li> <strong>代码隔离与接口抽象</strong> • 为存档管理定义<code class="language-plaintext highlighter-rouge">ISaveService</code>接口，允许替换实现（如测试用的内存存档）。 • 示例： <div class="language-gdscript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="c1"># 接口定义（通过GDscript的虚方法模拟）</span>
  <span class="k">class_name</span> <span class="n">ISaveService</span>
  <span class="k">func</span> <span class="nf">save_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">:</span> <span class="k">pass</span>

  <span class="c1"># 具体实现</span>
  <span class="k">class</span> <span class="nc">LocalSaveService</span> <span class="k">extends</span> <span class="n">ISaveService</span><span class="p">:</span>
      <span class="k">func</span> <span class="nf">save_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">:</span>
          <span class="c1"># 实际保存逻辑</span>
          <span class="k">return</span> <span class="bp">true</span>
</code></pre></div> </div> </li> <li> <strong>信号解耦</strong> • 用Godot信号通知存档/音频事件，而非直接调用方法： <div class="language-gdscript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="c1"># 存档完成后发送信号</span>
  <span class="n">SignalBus</span><span class="o">.</span><span class="n">emit_signal</span><span class="p">(</span><span class="s2">"save_finished"</span><span class="p">)</span>
  <span class="c1"># 其他节点监听信号</span>
  <span class="n">SignalBus</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">"save_finished"</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">"_on_save_finished"</span><span class="p">)</span>
</code></pre></div> </div> </li> <li> <strong>测试友好设计</strong> • 通过依赖注入替换单例： <div class="language-gdscript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="c1"># 测试中用MockAudioManager替换真实单例</span>
  <span class="k">func</span> <span class="nf">test_shoot_sound</span><span class="p">():</span>
      <span class="k">var</span> <span class="n">mock_audio</span> <span class="o">=</span> <span class="n">MockAudioManager</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
      <span class="n">player</span><span class="o">.</span><span class="n">audio_manager</span> <span class="o">=</span> <span class="n">mock_audio</span>
      <span class="n">player</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
      <span class="nb">assert</span><span class="p">(</span><span class="n">mock_audio</span><span class="o">.</span><span class="n">last_played</span> <span class="o">==</span> <span class="s2">"shoot"</span><span class="p">)</span>
</code></pre></div> </div> </li> </ol> <hr> <h3 id="总结"><strong>总结</strong></h3> <p>• <strong>推荐方案</strong>： • <strong>单例模式（AutoLoad）</strong>：适用于高频访问的基础服务（如音频、存档），配合信号解耦。 • <strong>依赖注入</strong>：用于需要高可测试性和模块化的复杂业务逻辑。 • <strong>避免全局变量</strong>：直接使用全局变量会破坏封装性，应通过AutoLoad或服务定位器抽象。 • <strong>Godot特性结合</strong>：善用<code class="language-plaintext highlighter-rouge">@export</code>暴露依赖、<code class="language-plaintext highlighter-rouge">SignalBus</code>全局信号总线，平衡开发效率与架构质量。</p> <h2 id="问题汇总2">问题汇总（2）</h2> <p>在Godot游戏开发中，除了依赖注入外，还有许多最佳实践可以提升代码质量、可维护性和团队协作效率。以下是详细说明及具体示例：</p> <hr> <h3 id="1-场景分层与模块化">1. <strong>场景分层与模块化</strong> </h3> <p><strong>核心思想</strong>：将游戏拆分为独立、可复用的场景，通过组合而非继承构建复杂系统。<br> <strong>实现方法</strong>： • <strong>子场景封装</strong>：将功能单元（如玩家的攻击组件、UI控件）封装成独立场景，通过实例化复用。 • <strong>场景树分层</strong>：例如将游戏分为 <code class="language-plaintext highlighter-rouge">Main</code>（根）、<code class="language-plaintext highlighter-rouge">UI</code>、<code class="language-plaintext highlighter-rouge">World</code>（游戏世界）、<code class="language-plaintext highlighter-rouge">Player</code> 等层级，避免节点混乱。</p> <p><strong>示例</strong>：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 场景结构
Main (Node2D)
├── UI (CanvasLayer)
│   ├── HealthBar.tscn
│   └── PauseMenu.tscn
└── World (Node2D)
    ├── Player.tscn
    └── Enemies (Node2D)
        ├── EnemyA.tscn
        └── EnemyB.tscn
</code></pre></div></div> <p><strong>优点</strong>： • 减少场景复杂度，便于多人协作。 • 通过 <code class="language-plaintext highlighter-rouge">Ctrl + S</code> 保存场景即可完成模块更新。</p> <hr> <h3 id="2-信号驱动的通信">2. <strong>信号驱动的通信</strong> </h3> <p><strong>核心思想</strong>：用Godot内置的 <strong>信号系统（Signals）</strong> 替代直接方法调用，实现松耦合。<br> <strong>实现方法</strong>： • 为节点定义自定义信号（如 <code class="language-plaintext highlighter-rouge">player_damaged</code>），其他节点通过 <code class="language-plaintext highlighter-rouge">connect</code> 监听。 • 使用 <strong>全局信号总线（SignalBus）</strong> 统一管理跨场景通信。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 全局Signal.gd（AutoLoad单例）</span>
<span class="k">signal</span> <span class="n">player_took_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
<span class="k">signal</span> <span class="n">game_paused</span>

<span class="c1"># Player.gd</span>
<span class="k">func</span> <span class="nf">take_damage</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="n">emit_signal</span><span class="p">(</span><span class="s2">"player_took_damage"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

<span class="c1"># UI/HealthBar.gd</span>
<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="n">SignalBus</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">"player_took_damage"</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">"_update_health"</span><span class="p">)</span>

<span class="k">func</span> <span class="nf">_update_health</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span>
    <span class="c1"># 更新血条逻辑</span>
</code></pre></div></div> <p><strong>优点</strong>： • 彻底解耦发送者和接收者，无需知道对方存在。 • 适用于跨场景事件（如成就系统、全局UI更新）。</p> <hr> <h3 id="3-资源管理resource和resourceloader">3. <strong>资源管理（Resource和ResourceLoader）</strong> </h3> <p><strong>核心思想</strong>：利用Godot的 <strong>Resource</strong> 系统管理游戏数据，通过预加载和缓存优化性能。<br> <strong>实现方法</strong>： • <strong>预加载常用资源</strong>：在启动时用 <code class="language-plaintext highlighter-rouge">preload</code> 或 <code class="language-plaintext highlighter-rouge">ResourceLoader.load</code> 加载关键资源。 • <strong>异步加载</strong>：使用 <code class="language-plaintext highlighter-rouge">ResourceLoader.load_interactive</code> 分帧加载大资源，避免卡顿。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 预定义资源类（如游戏设置）</span>
<span class="k">class_name</span> <span class="n">GameSettings</span> <span class="k">extends</span> <span class="n">Resource</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">master_volume</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">resolution</span><span class="p">:</span> <span class="kt">Vector2</span> <span class="o">=</span> <span class="kt">Vector2</span><span class="p">(</span><span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">)</span>

<span class="c1"># 加载资源</span>
<span class="k">var</span> <span class="n">settings</span><span class="p">:</span> <span class="n">GameSettings</span> <span class="o">=</span> <span class="n">ResourceLoader</span><span class="o">.</span><span class="nb">load</span><span class="p">(</span><span class="s2">"res://config/game_settings.tres"</span><span class="p">)</span>

<span class="c1"># 异步加载场景</span>
<span class="k">func</span> <span class="nf">load_level_async</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">):</span>
    <span class="k">var</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">ResourceLoader</span><span class="o">.</span><span class="n">load_interactive</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">true</span><span class="p">:</span>
        <span class="k">var</span> <span class="n">err</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="n">ERR_FILE_EOF</span><span class="p">:</span>
            <span class="k">var</span> <span class="n">level</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_resource</span><span class="p">()</span>
            <span class="n">get_tree</span><span class="p">()</span><span class="o">.</span><span class="n">change_scene_to</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">OK</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="nb">yield</span><span class="p">(</span><span class="n">get_tree</span><span class="p">(),</span> <span class="s2">"idle_frame"</span><span class="p">)</span>  <span class="c1"># 分帧加载</span>
</code></pre></div></div> <p><strong>优点</strong>： • 资源与代码分离，便于非程序员修改（如美术调整材质）。 • 避免重复加载，提升性能。</p> <hr> <h3 id="4-使用groups管理行为">4. <strong>使用Groups管理行为</strong> </h3> <p><strong>核心思想</strong>：通过节点分组（Groups）批量操作或查询节点，替代遍历场景树。<br> <strong>实现方法</strong>： • 将同类节点（如所有敌人）加入组（如 <code class="language-plaintext highlighter-rouge">"enemies"</code>），通过 <code class="language-plaintext highlighter-rouge">get_tree().get_nodes_in_group()</code> 获取。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 将所有敌人加入"enemies"组</span>
<span class="k">func</span> <span class="nf">_ready</span><span class="p">():</span>
    <span class="n">add_to_group</span><span class="p">(</span><span class="s2">"enemies"</span><span class="p">)</span>

<span class="c1"># 暂停所有敌人</span>
<span class="k">func</span> <span class="nf">pause_all_enemies</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">enemy</span> <span class="ow">in</span> <span class="n">get_tree</span><span class="p">()</span><span class="o">.</span><span class="n">get_nodes_in_group</span><span class="p">(</span><span class="s2">"enemies"</span><span class="p">):</span>
        <span class="n">enemy</span><span class="o">.</span><span class="n">pause</span><span class="p">()</span>
</code></pre></div></div> <p><strong>优点</strong>： • 简化代码，避免硬编码节点路径。 • 动态管理分组（如 <code class="language-plaintext highlighter-rouge">remove_from_group()</code>）。</p> <hr> <h3 id="5-state模式与状态机">5. <strong>State模式与状态机</strong> </h3> <p><strong>核心思想</strong>：用状态机管理复杂对象（如玩家、敌人）的行为切换，避免条件分支膨胀。<br> <strong>实现方法</strong>： • 每个状态封装为独立类，通过 <code class="language-plaintext highlighter-rouge">enter()</code>、<code class="language-plaintext highlighter-rouge">exit()</code>、<code class="language-plaintext highlighter-rouge">update()</code> 管理逻辑。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PlayerState.gd（基类）</span>
<span class="k">class_name</span> <span class="n">PlayerState</span>
<span class="k">func</span> <span class="nf">enter</span><span class="p">(</span><span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">):</span> <span class="k">pass</span>
<span class="k">func</span> <span class="nf">exit</span><span class="p">(</span><span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">):</span> <span class="k">pass</span>
<span class="k">func</span> <span class="nf">update</span><span class="p">(</span><span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="kt">float</span><span class="p">):</span> <span class="k">pass</span>

<span class="c1"># IdleState.gd</span>
<span class="k">extends</span> <span class="n">PlayerState</span>
<span class="k">func</span> <span class="nf">update</span><span class="p">(</span><span class="n">player</span><span class="p">:</span> <span class="n">Player</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="kt">float</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">Input</span><span class="o">.</span><span class="n">is_action_pressed</span><span class="p">(</span><span class="s2">"move_left"</span><span class="p">):</span>
        <span class="n">player</span><span class="o">.</span><span class="n">change_state</span><span class="p">(</span><span class="n">RunState</span><span class="o">.</span><span class="n">new</span><span class="p">())</span>

<span class="c1"># Player.gd</span>
<span class="k">var</span> <span class="n">current_state</span><span class="p">:</span> <span class="n">PlayerState</span>

<span class="k">func</span> <span class="nf">change_state</span><span class="p">(</span><span class="n">new_state</span><span class="p">:</span> <span class="n">PlayerState</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">current_state</span><span class="p">:</span>
        <span class="n">current_state</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">current_state</span> <span class="o">=</span> <span class="n">new_state</span>
    <span class="n">current_state</span><span class="o">.</span><span class="n">enter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="k">func</span> <span class="nf">_physics_process</span><span class="p">(</span><span class="n">delta</span><span class="p">):</span>
    <span class="n">current_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
</code></pre></div></div> <p><strong>优点</strong>： • 状态逻辑隔离，易于扩展新状态（如攀爬、游泳）。 • 避免大量 <code class="language-plaintext highlighter-rouge">if-else</code> 判断。</p> <hr> <h3 id="6-避免过度继承多用组合">6. <strong>避免过度继承，多用组合</strong> </h3> <p><strong>核心思想</strong>：利用Godot节点的组合特性，通过添加子节点实现功能扩展，而非深度继承。<br> <strong>实现方法</strong>： • 将功能拆分为独立节点（如 <code class="language-plaintext highlighter-rouge">MovementComponent</code>、<code class="language-plaintext highlighter-rouge">AttackComponent</code>），挂载到父节点。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># MovementComponent.gd</span>
<span class="k">class_name</span> <span class="n">MovementComponent</span>
<span class="k">extends</span> <span class="n">Node</span>

<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">speed</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">200.0</span>
<span class="k">var</span> <span class="n">velocity</span><span class="p">:</span> <span class="kt">Vector2</span> <span class="o">=</span> <span class="kt">Vector2</span><span class="o">.</span><span class="n">ZERO</span>

<span class="k">func</span> <span class="nf">move</span><span class="p">(</span><span class="n">direction</span><span class="p">:</span> <span class="kt">Vector2</span><span class="p">):</span>
    <span class="n">velocity</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">speed</span>

<span class="c1"># Player.gd</span>
<span class="err">@</span><span class="k">onready</span> <span class="k">var</span> <span class="n">movement</span><span class="p">:</span> <span class="n">MovementComponent</span> <span class="o">=</span> <span class="o">$</span><span class="n">MovementComponent</span>

<span class="k">func</span> <span class="nf">_physics_process</span><span class="p">(</span><span class="n">delta</span><span class="p">):</span>
    <span class="n">movement</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">Input</span><span class="o">.</span><span class="n">get_vector</span><span class="p">(</span><span class="s2">"move_left"</span><span class="p">,</span> <span class="s2">"move_right"</span><span class="p">,</span> <span class="s2">"move_up"</span><span class="p">,</span> <span class="s2">"move_down"</span><span class="p">))</span>
</code></pre></div></div> <p><strong>优点</strong>： • 功能模块化，可动态替换（如不同角色的移动方式）。 • 符合Godot“场景即预制体”的设计哲学。</p> <hr> <h3 id="7-全局事件总线signalbus">7. <strong>全局事件总线（SignalBus）</strong> </h3> <p><strong>核心思想</strong>：通过单例管理全局事件，避免直接引用其他节点。<br> <strong>实现方法</strong>： • 创建 <code class="language-plaintext highlighter-rouge">SignalBus.gd</code> 作为AutoLoad单例，集中定义所有全局信号。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># SignalBus.gd（AutoLoad）</span>
<span class="k">signal</span> <span class="n">score_updated</span><span class="p">(</span><span class="n">new_score</span><span class="p">)</span>
<span class="k">signal</span> <span class="n">game_over</span>

<span class="c1"># 触发信号</span>
<span class="n">SignalBus</span><span class="o">.</span><span class="n">emit_signal</span><span class="p">(</span><span class="s2">"score_updated"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># 监听信号</span>
<span class="n">SignalBus</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">"score_updated"</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">"_on_score_updated"</span><span class="p">)</span>
</code></pre></div></div> <p><strong>优点</strong>： • 统一管理跨系统通信。 • 解耦事件发布者和订阅者。</p> <hr> <h3 id="8-自动化测试与调试工具">8. <strong>自动化测试与调试工具</strong> </h3> <p><strong>核心思想</strong>：通过单元测试和性能分析工具确保代码健壮性。<br> <strong>实现方法</strong>： • 使用GDScript的 <code class="language-plaintext highlighter-rouge">assert()</code> 和 <code class="language-plaintext highlighter-rouge">test_</code> 前缀函数编写测试。 • 利用Godot编辑器的 <strong>调试器</strong> 和 <strong>性能分析器（Profiler）</strong>。</p> <p><strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 测试玩家伤害逻辑</span>
<span class="k">func</span> <span class="nf">test_player_take_damage</span><span class="p">():</span>
    <span class="k">var</span> <span class="n">player</span> <span class="o">=</span> <span class="n">Player</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">player</span><span class="o">.</span><span class="n">health</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">player</span><span class="o">.</span><span class="n">take_damage</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="nb">assert</span><span class="p">(</span><span class="n">player</span><span class="o">.</span><span class="n">health</span> <span class="o">==</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div></div> <p><strong>工具推荐</strong>： • <strong>性能分析</strong>：查看CPU/GPU帧耗时、内存占用。 • <strong>远程调试</strong>：连接真机调试移动端游戏。</p> <hr> <h3 id="9-版本控制与场景组织规范">9. <strong>版本控制与场景组织规范</strong> </h3> <p><strong>核心思想</strong>：制定团队协作的目录结构和命名规范，避免冲突。<br> <strong>推荐结构</strong>：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>res://
├── actors/         # 角色相关
├── ui/             # 界面
├── levels/         # 关卡
├── resources/      # 资源（音效、材质）
│   ├── audio/
│   └── textures/
└── scripts/        # 全局脚本
</code></pre></div></div> <p><strong>命名规范</strong>： • 场景文件：<code class="language-plaintext highlighter-rouge">名词_动词.tscn</code>（如 <code class="language-plaintext highlighter-rouge">enemy_flying.tscn</code>）。 • 脚本变量：<code class="language-plaintext highlighter-rouge">snake_case</code>，公开变量用 <code class="language-plaintext highlighter-rouge">@export</code>。</p> <hr> <h3 id="10-自定义资源custom-resources">10. <strong>自定义资源（Custom Resources）</strong> </h3> <p><strong>核心思想</strong>：将配置数据（如角色属性、关卡数据）存储为 <code class="language-plaintext highlighter-rouge">.tres</code> 文件，与代码分离。<br> <strong>示例</strong>：</p> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># CharacterStats.gd</span>
<span class="k">class_name</span> <span class="n">CharacterStats</span> <span class="k">extends</span> <span class="n">Resource</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">max_health</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">100</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">speed</span><span class="p">:</span> <span class="kt">float</span> <span class="o">=</span> <span class="mf">150.0</span>

<span class="c1"># 在编辑器中创建CharacterStats资源并赋值</span>
<span class="err">@</span><span class="k">export</span> <span class="k">var</span> <span class="n">stats</span><span class="p">:</span> <span class="n">CharacterStats</span>
</code></pre></div></div> <p><strong>优点</strong>： • 非程序员可直接在编辑器中调整数值。 • 支持继承资源（<code class="language-plaintext highlighter-rouge">class_name InheritedStats extends CharacterStats</code>）。</p> <hr> <h3 id="总结-1"><strong>总结</strong></h3> <p>Godot的最佳实践核心是 <strong>“充分利用引擎特性，保持代码简洁、模块化”</strong>：</p> <ol> <li> <strong>优先场景和节点组合</strong>，而非复杂继承。</li> <li> <strong>全局通信用信号</strong>，避免直接调用。</li> <li> <strong>资源与代码分离</strong>，提升可维护性。</li> <li> <strong>自动化测试</strong>确保关键逻辑稳定。</li> </ol> <p>这些实践结合Godot的节点树、信号系统和资源管理，能显著提升企业级项目的开发效率和代码质量。</p> <h2 id="问题汇总3">问题汇总（3）</h2> <p>在Godot企业级游戏开发中，遵循特定的设计原则和模式可以显著提升代码的可维护性、扩展性和团队协作效率。以下是详细总结及具体应用场景：</p> <hr> <h3 id="一核心设计原则"><strong>一、核心设计原则</strong></h3> <h4 id="1-solid原则">1. <strong>SOLID原则</strong> </h4> <p>• <strong>Single Responsibility (单一职责)</strong><br> ◦ 每个类/节点只负责一个功能（如 <code class="language-plaintext highlighter-rouge">MovementComponent</code> 仅处理移动逻辑）。 • <strong>Open/Closed (开闭原则)</strong><br> ◦ 通过继承 <code class="language-plaintext highlighter-rouge">Resource</code> 扩展物品类型，而非修改原有代码。 • <strong>Liskov Substitution (里氏替换)</strong><br> ◦ 子类技能必须兼容父类接口（如所有技能实现 <code class="language-plaintext highlighter-rouge">activate()</code> 方法）。 • <strong>Interface Segregation (接口隔离)</strong><br> ◦ 为装备和消耗品定义不同的接口（<code class="language-plaintext highlighter-rouge">IEquippable</code>、<code class="language-plaintext highlighter-rouge">IConsumable</code>）。 • <strong>Dependency Inversion (依赖倒置)</strong><br> ◦ 通过依赖注入传递存档服务（如 <code class="language-plaintext highlighter-rouge">ISaveService</code>）。</p> <h4 id="2-组合优于继承-composition-over-inheritance">2. <strong>组合优于继承 (Composition over Inheritance)</strong> </h4> <p>• 使用节点组合构建角色：将 <code class="language-plaintext highlighter-rouge">AttackComponent</code>、<code class="language-plaintext highlighter-rouge">InventoryComponent</code> 挂载到 <code class="language-plaintext highlighter-rouge">Player</code> 节点，而非创建多层继承。</p> <h4 id="3-dont-repeat-yourself-dry">3. <strong>Don’t Repeat Yourself (DRY)</strong> </h4> <p>• 将通用逻辑（如对象池管理）封装在 <code class="language-plaintext highlighter-rouge">Utils/ObjectPool.gd</code> 中。</p> <h4 id="4-kiss-keep-it-simple">4. <strong>KISS (Keep It Simple)</strong> </h4> <p>• 避免过度设计：小型模块直接使用Godot信号，而非强制引入复杂框架。</p> <hr> <h3 id="二常用设计模式及企业级应用"><strong>二、常用设计模式及企业级应用</strong></h3> <h4 id="1-单例模式-singleton">1. <strong>单例模式 (Singleton)</strong> </h4> <p>• <strong>实现方式</strong>：通过 <code class="language-plaintext highlighter-rouge">AutoLoad</code> 创建全局服务。 • <strong>应用场景</strong>： ◦ <strong>存档管理</strong>：<code class="language-plaintext highlighter-rouge">SaveManager</code> 统一处理加密、云同步。 ◦ <strong>音频管理</strong>：<code class="language-plaintext highlighter-rouge">AudioManager</code> 控制音效优先级和混音。 ◦ <strong>全局事件总线</strong>：<code class="language-plaintext highlighter-rouge">SignalBus</code> 管理跨系统通信。</p> <h4 id="2-观察者模式-observer">2. <strong>观察者模式 (Observer)</strong> </h4> <p>• <strong>实现方式</strong>：Godot内置的 <code class="language-plaintext highlighter-rouge">信号（Signals）</code>。 • <strong>应用场景</strong>： ◦ <strong>背包系统</strong>：物品数量变化时发送 <code class="language-plaintext highlighter-rouge">item_updated</code> 信号更新UI。 ◦ <strong>成就系统</strong>：监听 <code class="language-plaintext highlighter-rouge">enemy_killed</code> 事件触发成就解锁。 ◦ <strong>技能系统</strong>：技能冷却结束时通知UI刷新按钮状态。</p> <h4 id="3-工厂模式-factory">3. <strong>工厂模式 (Factory)</strong> </h4> <p>• <strong>实现方式</strong>：通过 <code class="language-plaintext highlighter-rouge">ResourceLoader</code> 动态创建对象。 • <strong>应用场景</strong>： ◦ <strong>物品生成</strong>：<code class="language-plaintext highlighter-rouge">ItemFactory.create_item("sword")</code> 根据ID生成装备。 ◦ <strong>敌人生成</strong>：<code class="language-plaintext highlighter-rouge">EnemyFactory.spawn("boss")</code> 加载不同敌人场景。</p> <h4 id="4-状态模式-state">4. <strong>状态模式 (State)</strong> </h4> <p>• <strong>实现方式</strong>：每个状态封装为独立类。 • <strong>应用场景</strong>： ◦ <strong>玩家控制</strong>：<code class="language-plaintext highlighter-rouge">IdleState</code>、<code class="language-plaintext highlighter-rouge">RunState</code>、<code class="language-plaintext highlighter-rouge">AttackState</code> 管理行为切换。 ◦ <strong>游戏流程</strong>：<code class="language-plaintext highlighter-rouge">MainMenuState</code>、<code class="language-plaintext highlighter-rouge">PlayingState</code>、<code class="language-plaintext highlighter-rouge">PausedState</code> 控制游戏阶段。</p> <h4 id="5-策略模式-strategy">5. <strong>策略模式 (Strategy)</strong> </h4> <p>• <strong>实现方式</strong>：通过接口抽象算法。 • <strong>应用场景</strong>： ◦ <strong>存档格式</strong>：定义 <code class="language-plaintext highlighter-rouge">ISaveStrategy</code>，实现 <code class="language-plaintext highlighter-rouge">JsonSaveStrategy</code> 和 <code class="language-plaintext highlighter-rouge">BinarySaveStrategy</code>。 ◦ <strong>伤害计算</strong>：<code class="language-plaintext highlighter-rouge">DamageCalculator</code> 支持多种算法（如物理、魔法、暴击）。</p> <h4 id="6-命令模式-command">6. <strong>命令模式 (Command)</strong> </h4> <p>• <strong>实现方式</strong>：封装操作为可撤销的对象。 • <strong>应用场景</strong>： ◦ <strong>技能释放</strong>：<code class="language-plaintext highlighter-rouge">CastFireballCommand</code> 记录施法目标和时间，支持撤销。 ◦ <strong>UI操作</strong>：实现编辑器的撤销/重做功能。</p> <h4 id="7-对象池模式-object-pool">7. <strong>对象池模式 (Object Pool)</strong> </h4> <p>• <strong>实现方式</strong>：预实例化对象并重复利用。 • <strong>应用场景</strong>： ◦ <strong>子弹管理</strong>：避免频繁实例化/销毁子弹对象。 ◦ <strong>粒子效果</strong>：复用爆炸、烟雾等特效节点。</p> <hr> <h3 id="三企业级模块设计与实现"><strong>三、企业级模块设计与实现</strong></h3> <h4 id="1-背包系统">1. <strong>背包系统</strong> </h4> <p>• <strong>设计要点</strong>： ◦ <strong>数据分离</strong>：用 <code class="language-plaintext highlighter-rouge">InventoryItem</code> 资源定义物品属性。 ◦ <strong>拖拽交互</strong>：通过 <code class="language-plaintext highlighter-rouge">Control</code> 节点的 <code class="language-plaintext highlighter-rouge">_get_drag_data</code> 和 <code class="language-plaintext highlighter-rouge">_drop_data</code> 实现。 ◦ <strong>动态渲染</strong>：使用 <code class="language-plaintext highlighter-rouge">GridContainer</code> 和对象池管理槽位UI。 • <strong>代码示例</strong>： <code class="language-plaintext highlighter-rouge">gdscript # 物品拖拽 func _get_drag_data(position: Vector2): var item = slots[slot_index].item var preview = TextureRect.new() preview.texture = item.icon set_drag_preview(preview) return {"source_slot": slot_index, "item": item} </code></p> <h4 id="2-技能系统">2. <strong>技能系统</strong> </h4> <p>• <strong>设计要点</strong>： ◦ <strong>技能数据驱动</strong>：用 <code class="language-plaintext highlighter-rouge">SkillData</code> 资源定义冷却时间、伤害公式。 ◦ <strong>组合技能</strong>：通过 <code class="language-plaintext highlighter-rouge">CompositeSkill</code> 组合多个基础技能（如冰火融合技）。 ◦ <strong>状态同步</strong>：用信号通知技能就绪状态（<code class="language-plaintext highlighter-rouge">skill_ready</code>、<code class="language-plaintext highlighter-rouge">skill_cooldown</code>）。 • <strong>代码示例</strong>： ```gdscript # 技能基类 class_name BaseSkill extends Resource signal cooldown_updated(remaining: float)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> func activate(caster: Node) -&gt; bool:
     # 由子类实现具体逻辑
     pass
 ```
</code></pre></div></div> <h4 id="3-存档管理">3. <strong>存档管理</strong> </h4> <p>• <strong>设计要点</strong>： ◦ <strong>版本兼容</strong>：存档数据包含版本号，支持旧版迁移。 ◦ <strong>异步保存</strong>：使用 <code class="language-plaintext highlighter-rouge">Thread</code> 或 <code class="language-plaintext highlighter-rouge">Mutex</code> 避免主线程卡顿。 ◦ <strong>加密存储</strong>：通过 <code class="language-plaintext highlighter-rouge">Crypto</code> 类对敏感数据加密。 • <strong>代码示例</strong>： ```gdscript # 异步保存 func save_async(path: String): var thread = Thread.new() thread.start(_save_data.bind(path))</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> func _save_data(path: String):
     var json = JSON.stringify(data)
     ResourceSaver.save(json, path)
 ```
</code></pre></div></div> <h4 id="4-ai系统">4. <strong>AI系统</strong> </h4> <p>• <strong>设计要点</strong>： ◦ <strong>行为树</strong>：用 <code class="language-plaintext highlighter-rouge">BehaviorTree</code> 节点实现复杂AI逻辑。 ◦ <strong>感知系统</strong>：通过 <code class="language-plaintext highlighter-rouge">Area2D</code> 检测玩家位置。 ◦ <strong>配置化</strong>：用 <code class="language-plaintext highlighter-rouge">AIConfig</code> 资源调整AI参数（如巡逻半径、反应速度）。</p> <h4 id="5-网络同步多人游戏">5. <strong>网络同步（多人游戏）</strong> </h4> <p>• <strong>设计要点</strong>： ◦ <strong>权威服务器</strong>：关键逻辑（如伤害计算）在服务器执行。 ◦ <strong>状态同步</strong>：通过 <code class="language-plaintext highlighter-rouge">multiplayer</code> API同步玩家位置、状态。 ◦ <strong>预测与插值</strong>：客户端实现移动预测，平滑显示其他玩家动作。</p> <hr> <h3 id="四godot特性深度结合"><strong>四、Godot特性深度结合</strong></h3> <ol> <li> <p><strong>节点树与场景化开发</strong><br> • 将功能拆分为子场景（如 <code class="language-plaintext highlighter-rouge">UI/PopupDialog.tscn</code>），通过 <code class="language-plaintext highlighter-rouge">instance()</code> 动态加载。</p> </li> <li> <p><strong>资源系统（Resource）</strong><br> • 用 <code class="language-plaintext highlighter-rouge">.tres</code> 文件存储配置数据（如角色属性、关卡配置）。</p> </li> <li> <strong>信号系统</strong><br> • 替代回调函数，实现解耦： <div class="language-gdscript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="c1"># 发送信号</span>
  <span class="n">SignalBus</span><span class="o">.</span><span class="n">emit_signal</span><span class="p">(</span><span class="s2">"player_health_changed"</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>
  <span class="c1"># 监听信号</span>
  <span class="n">SignalBus</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">"player_health_changed"</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">update_health_bar</span><span class="p">)</span>
</code></pre></div> </div> </li> <li> <strong>编辑器扩展</strong><br> • 通过 <code class="language-plaintext highlighter-rouge">@tool</code> 脚本创建自定义编辑器工具，提升团队效率。</li> </ol> <hr> <h3 id="五企业级开发注意事项"><strong>五、企业级开发注意事项</strong></h3> <ol> <li> <p><strong>代码规范</strong><br> • 强制使用静态类型（<code class="language-plaintext highlighter-rouge">var health: int = 100</code>）和命名约定（如 <code class="language-plaintext highlighter-rouge">snake_case</code>）。</p> </li> <li> <p><strong>性能优化</strong><br> • 使用 <code class="language-plaintext highlighter-rouge">Profiler</code> 分析CPU/GPU耗时，避免每帧执行高开销操作。</p> </li> <li> <p><strong>跨平台适配</strong><br> • 通过 <code class="language-plaintext highlighter-rouge">OS.get_name()</code> 处理平台差异（如移动端虚拟摇杆、PC端键鼠控制）。</p> </li> <li> <p><strong>自动化测试</strong><br> • 编写单元测试验证核心逻辑（如伤害计算、物品堆叠）。</p> </li> </ol> <hr> <h3 id="总结-2"><strong>总结</strong></h3> <p>在Godot企业级开发中，关键在于 <strong>“充分利用引擎特性，结合经典设计模式”</strong>： • <strong>原则</strong>：优先使用组合、SOLID、DRY。 • <strong>模式</strong>：单例、观察者、工厂、状态模式为核心。 • <strong>实践</strong>：模块化拆分、数据驱动设计、资源与代码分离。</p> <p>通过以上方法，可以在复杂项目（如开放世界RPG、MMO）中实现高效协作和长期维护。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/" target="_blank" rel="external nofollow noopener">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">依赖注入的最佳实践</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/%E5%8F%88%E5%BC%80%E5%A7%8B%E5%B9%BB%E6%83%B3%E4%BA%86-%E6%81%BC/">又开始幻想了“恼”！</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">手册学习之最佳实践</a> </li> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 The uifj. Made with ❤️ in 🇧🇷.<br> Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/plotly.js@3.0.1/dist/plotly.min.js" integrity="sha256-oy6Be7Eh6eiQFs5M7oXuPxxm9qbJXEtTpfSI93dW16Q=" crossorigin="anonymous"></script> <script defer src="/assets/js/plotly-setup.js?5e81fc889064852664784cb29c0d6970" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>